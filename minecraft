#!/bin/bash
# /etc/init.d/minecraft

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Init script for minecraft/bukkit server, with rolling logs and use of ramdisk for less lag.
### END INIT INFO

# Created by Ahtenus

# Based on http://www.minecraftwiki.net/wiki/Server_startup_script
# Support for multiworld by Benni-chan
# Log rolls without needing restarts by Solorvox
# Option for killing server in an emergency by jbondhus



###############################################################################
## Bootstrap
###############################################################################

set -u;	# error on undeclared var
set -e;	# exit on error



###############################################################################
## Define constants
###############################################################################


## name of the current script
export readonly SELF="$(basename "$0")";


## Quiet		:= no output
readonly export VERBOSITY_QUIET=-1;


## Default		:= success messages; etc
readonly export VERBOSITY_DEFAULT=0;


## Info			:= values of subshells; function-calls, in prose
readonly export VERBOSITY_INFO=1;


## Verbose		:= final value of vars, in prose
readonly export VERBOSITY_VERBOSE=2;


## Debugging	:= all possible outputs, tersely
readonly export VERBOSITY_DEBUG=3;



###############################################################################
## Init vars
###############################################################################


## default location of config [same dir as $0]
CONFIG_FILE="$(dirname "$(readlink -e "$0")")/config";


## Level of debugging-info to output
VERBOSITY=$VERBOSITY_DEFAULT;



###############################################################################
## Functions
###############################################################################



########
# Output the current version of MineCraft-Init
########
function echo_mci_version() {
	echo_quiet '2.7.3';
	return 0;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#   VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Verbosity-level, e.g. VERBOSITY_QUIET
#	2	Message
#
# Returns
#	0|1
########
function echo_by_level {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Verbosity-level is not an integer; quitting";
		return 1;
	fi;


	# if this message is verbose, but we're quieter, stop here
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	local message="$2";


	# if debugging, prefix with function
	if [ "$1" -ge "$VERBOSITY_DEBUG" ]; then
		message="[${FUNCNAME[2]}] $message";
	fi;


	# put to stdout
	echo -e "$message";


	return 0;
}


## wrappers for echo_by_level
function echo_quiet()	{ echo_by_level "$VERBOSITY_QUIET"		"${1-}";	return $?; }
function echo_out()		{ echo_by_level "$VERBOSITY_DEFAULT"	"${1-}";	return $?; }
function echo_info()	{ echo_by_level "$VERBOSITY_INFO"		"${1-}";	return $?; }
function echo_verbose()	{ echo_by_level "$VERBOSITY_VERBOSE"	"${1-}";	return $?; }
function echo_debug()	{
	local status=0;

	echo_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;
	log_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;

	return $status;
}



########
# Send errors to stderr
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo()
########
function echo_err() {
	echo -e "$@" 1>&2;
	return $?;
}



########
# Send errors to stderr
#
# DEPRECATED by echo_err()
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo_err()
########
function echoerr() {
	echo_err "echoerr() is deprecated; use echo_err() instead";
	echo_err "$@";
	return $?;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#   VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Log-level := VERBOSITY_QUIET <-> VERBOSITY_DEBUG
#	2	Message
#
# Returns
#	0|1
########
function log_by_level() {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Log-level is not an integer; quitting";
		return 1;
	fi;


	# if we're too quiet to show the message, finish
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	## if we haven't loaded the config yet, echo to stdout
	if [ -z "${MCPATH-}" ]; then
		echo -e "$2" >&2;
		return 0;
	fi;


	# if can't write to file, crash
	if [ ! -f "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't find latest.log in $MCPATH/logs/; crashing";
		exit 1;
	fi;
	if [ ! -w "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't write to $MCPATH/logs/latest.log; crashing";
		exit 1;
	fi;


	# log to file -- with date, level, function
	local function_name="${FUNCNAME[1]}";	# get calling function
	function_name="${function_name#log_}";	# if log_foo, remove prefix
	function_name="${function_name#echo_}";	# if echo_foo, remove prefix
	echo "[$(date +%Y-%m-%d:%H:%M:%S)] [$function_name] [${FUNCNAME[2]}] $2" >> "$MCPATH/logs/latest.log";


	return 0;
}


## wrappers for log_by_level
function log_quiet()	{ log_by_level "$VERBOSITY_QUIET" "$1";		return $?; }
function log()			{ log_by_level "$VERBOSITY_DEFAULT" "$1";	return $?; }
function log_info()		{ log_by_level "$VERBOSITY_INFO" "$1";		return $?; }
function log_verbose()	{ log_by_level "$VERBOSITY_VERBOSE" "$1";	return $?; }
function log_debug()	{ log_by_level "$VERBOSITY_DEBUG" "$1"; 	return $?; }


## output supported commands
function echo_usage {
	echo_quiet "Usage: $SELF [<options>] <command>";
	echo_out;
	echo_out "Where <options> is zero or more of:";
	echo_out "   -c <file>     Config. Loads the given config file. Default is $(dirname "$0")/config";
	echo_out "   -q            Quiet. Decreases the script's verbosity";
	echo_out "   -v            Verbose. Increases the script's verbosity. May be repeated. Max is three";
	echo_out;
	echo_out "Where <command> is one of:";
	echo_out "   start \t\t Starts the server";
	echo_out "   stop \t\t Stops the server";
	echo_out "   kill \t\t Kills the server";
	echo_out "   restart \t\t Restarts the server";
	echo_out "   watchdog \t Ensures server is still running";
	echo_out "   reload \t\t Reloads the server configuration";
	echo_out "   backup \t\t Backups the worlds defined in the script";
	echo_out "   whole-backup \t Backups the entire server folder";
	echo_out "   check-upgrade \t Checks for new versions of $CB_JAR and $MC_JAR";
	echo_out "   upgrade \t\t Fetches the latest version of minecraft.jar server and Bukkit";
	echo_out "   log-roll \t\t Moves and compresses the logfiles";
	echo_out "   log \t\t\t Prints the server log";
	echo_out "   to-disk \t\t Copies the worlds from the ramdisk to worldstorage";
	echo_out "   save-off \t\t Flushes the world to disk and then disables saving";
	echo_out "   save-on \t\t Re-enables saving if it was previously disabled by save-off";
	echo_out "   say \t\t\t Prints the given string to the ingame chat";
	echo_out "   connected \t\t Lists connected users";
	echo_out "   playercount \t\t Prints the number of connected users";
	echo_out "   status \t\t Displays server status";
	echo_out "   version \t\t Displays Bukkit version and then exits";
	echo_out "   link-worlds \t\t Creates necessary symlinks from your server folder to your saved world";
	echo_out "   last \t\t Displays recently connected users";
	echo_out "   worlds \t\t Displays a list of available worlds";
	echo_out "   ramdisk WORLD \t Toggles ramdisk configuration for WORLD";
	echo_out "   overviewer WORLD \t Creates a map of the WORLD with Minecraft-Overviewer";
	echo_out "   whitelist \t\t Prints the current whitelist";
	echo_out "   whitelist-add NAME \t Adds the specified player to the server whitelist";
	echo_out "   whitelist-reload \t Reloads the whitelist";
	echo_out "   screen \t\t Shows the server screen";
	echo_out "   script-version        Show this script's version";
	echo_out "   help \t\t Shows this text";

	return 0;
}



########
# Extract commandline parameters from call
#
# Globals
#   CONFIG_FILE			Set by -c
#   INIT_COMMAND		The command to run
#   INIT_SUBCOMMAND		The sub-command to run and/or message to pass, etc
#   VERBOSITY			Incremented by -v; reset by -q
#
# Arguments
#   @					All commandline parameters
#
# Returns
#   0|1
########
function handle_commandline_options {
	echo_debug "@=$*";
	echo_debug "#=$#";


	OPTIND=1;		# Reset in case getopts has been used previously in the shell.
	while getopts 'c:qv' option; do
		echo_debug "option=$option";

		case "$option" in
			c)	CONFIG_FILE="$(echo "$OPTARG" | xargs)";	# strip whitespace
				;;


			q)	VERBOSITY=$VERBOSITY_QUIET;
				;;


			v)	VERBOSITY=$((VERBOSITY+1));
				;;


			*)	echo_err "Unrecognised parameter '$option'; quitting";
				return 1;
				;;


		esac;
	done;
	echo_debug "CONFIG_FILE=$CONFIG_FILE";
	echo_debug "VERBOSITY=$VERBOSITY";


	shift $((OPTIND-1));	# skip the params we've already processed


	export readonly INIT_COMMAND="${1-}";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";

	export readonly INIT_SUBCOMMAND="${2-}";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";


	return 0;
}



########
# Loads defaults, loads (selected?) config file, and sets derived params
#
# Globals
#	CONFIG_FILE		Location of local config file; used in error message
#	INVOCATION		Command-string to start the server
#	SERVICE			Jar to run; used to test config is loaded
#
# Arguments
#	None
#
# Returns
#	None
########
function config_load() {
	## load default config
	config_load_defaults || {
		echo_err "Can't load default config; crashing";
		exit 1;
	}


	## load local config
	config_load_local || {
		echo_err "Can't load local config ($CONFIG_FILE); crashing";
		exit 1;
	}


	## test config is loaded
	if [ -z "$SERVICE" ]; then
		logger -t minecraft-init "Can't load local config ($CONFIG_FILE); crashing";
		exit 1;
	fi


	## set dependant vars
	config_set_derived_variables || return 1;


	return 0;
}



########
# Initialises all configs to sensible default values; template for local config file
#
# Globals
#	Lots
#
# Arguments
#	None
#
# Returns
#	None
########
function config_load_defaults() {
	## config MineCraft
	MC_JAR="minecraft_server.jar";
	CB_JAR="craftbukkit.jar";
	SERVICE="$MC_JAR";
	MCPATH="/usr/lib/minecraft";
	SERVERLOG="${MCPATH}/logs/latest.log";
	WORLDSTORAGE="/var/lib/minecraft/data";

	## config minecraftd
	SCREEN="server_screen";
	USERNAME="minecraft";

	## hardware
	CPU_COUNT=2;
	INITMEM="2048M";
	MAXMEM="2048M";
	RAMDISK="/dev/shm";

	## backups
	BACKUPPATH="${MCPATH}/backup/world";
	WHOLEBACKUP="${MCPATH}/backup/server";
	BACKUPFORMAT="tar";
	BACKUPSCRIPTCOMPATIBLE=YES;
	COMPRESS_WHOLEBACKUP=YES;

	## logging
	LOGPATH="/var/log/minecraft";

	## upgrades
	MC_DOWNLOAD_PAGE='https://minecraft.net/download/server';	# Official page containing download link for the current minecraft_server.jar
	CB_RELEASE="stable";	# Define the release of CraftBukkit to use (stable or unstable)
	CB_DOWNLOAD_URL='http://dl.bukkit.org/latest-RELEASE/craftbukkit.jar';	# Link to latest $CB_JAR. 'RELEASE', if present, will be replaced with $CB_RELEASE

	## config MineCraft-Overviewer
	OUTPUTMAP="/home/${USERNAME}/mc-overviewer/render";
	OVPATH="/home/${USERNAME}/mc-overviewer/Minecraft-Overviewer";
	OVCONFIGPATH="/home/${USERNAME}/mc-overviewer";
	OVCONFIGNAME="config.py";
	OVBACKUP="/home/${USERNAME}/mc-overviewer/overviewerbackups";

	return 0;
}



########
# Loads local config file
#
# Globals
#	CONFIG_FILE		Location of file to load; set at commandline
#
# Arguments
#	None
#
# Returns
#	None
########
function config_load_local() {
	## check file exists
	if [ ! -f "$CONFIG_FILE" ] || [ ! -r "$CONFIG_FILE" ] ; then
		echo_err "Couldn't find config file ($CONFIG_FILE); crashing";
		echo_err "Please fix your command and try again, or copy config.example to '$(basename $CONFIG_FILE)'";
		exit 1;
	fi


	## load file
	source "$CONFIG_FILE" || {
		echo_err "Failed to load config file '$CONFIG_FILE'; crashing";
		exit 1;
	}


	return 0;
}



########
# Uses the loaded config to set dependant variables
#
# Globals
#	FLAVOUR			Vanilla MineCraft or derived version
#	INVOCATION		String to pass to Screen to start the server
#
# Arguments
#	None
#
# Returns
#	0		Success
#	1		Failure
########
function config_set_derived_variables() {
	## init vars
	local flavour;


	## Java + options
	readonly INVOCATION="java -Xmx$MAXMEM -Xms$INITMEM -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalPacing -XX:ParallelGCThreads=$CPU_COUNT -XX:+AggressiveOpts -jar $SERVICE nogui";


	## CraftBukkit or Vanilla?
	echo_debug "CB_JAR $CB_JAR";
	echo_debug "MC_JAR $MC_JAR";
	echo_debug "SERVICE $(basename "$SERVICE")";
	if [ "$MC_JAR" = "$(basename "$SERVICE")" ]; then
		flavour='vanilla';
	elif [ "$CB_JAR" = "$(basename "$SERVICE")" ]; then
		flavour='bukkit';
	else
		echo_err "Failed to find \$FLAVOUR. Have you set \$SERVICE? And \$MC_JAR or \$CB_JAR? Quitting";
		return 1;
	fi;
	readonly FLAVOUR="$flavour";


	return 0;
}



########
# Runs an arbitrary command as USERNAME
#
# Globals
#	USERNAME
#
# Arguments
#	1		Command to run
#
# Returns
#	0|1
########
as_user() {
	echo_debug "1=$1";


	if [ 1 -ne $# ] || [ -z "$1" ]; then
		echo_err "Command is missing or invalid; quitting";
		return 1;
	fi;


	local me="$(whoami)";
	echo_debug "me=$me";
	echo_debug "USERNAME=$USERNAME";


	# if we're already USERNAME, run
	if [ "$me" = "$USERNAME" ] ; then
		bash -c "$1" || return 1;
		return 0;
	fi;


	su "$USERNAME" -s /bin/bash -c "$1" || return 1;


	return 0;
}


is_running() {
	# Checks for the minecraft servers screen session
	# returns true if it exists.
	pidfile=${MCPATH}/${SCREEN}.pid

	if [ -f "$pidfile" ]
	then
		pid=$(head -1 $pidfile)
		if ps ax | grep -v grep | grep ${pid} | grep "${SCREEN}" > /dev/null
		then
			return 0
		else
			if [ -z "$isInStop" ]
			then
				if [ -z "$roguePrinted" ]
				then
					roguePrinted=1
					echo_err "Rogue pidfile found!"
				fi
			fi
			return 1
		fi
	else
		if ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" > /dev/null
		then
			echo_err "No pidfile found, but server's running."
			echo_err "Re-creating the pidfile."

			pid=$(ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" | cut -f1 -d' ')
			check_permissions
			as_user "echo $pid > $pidfile"

			return 0
		else
			return 1
		fi
	fi
}


datepath() {
	# datepath path filending-to-check returned-filending

	# Returns an file path with added date between the filename and file ending.
	# $1 filepath (not including file ending)
	# $2 file ending to check for uniqueness
	# $3 file ending to return

	if [ -e $1`date +%F`$2 ]
	then
		echo_quiet $1`date +%FT%T`$3
	else
		echo_quiet $1`date +%F`$3
	fi
}


mc_start() {
	servicejar=$MCPATH/$SERVICE
	if [ ! -f "$servicejar" ]
	then
		echo_err "Failed to start: Can't find the specified Minecraft jar under $servicejar. Please check your config!"
		exit 1
	fi

	pidfile=${MCPATH}/${SCREEN}.pid
	check_permissions

	as_user "cd $MCPATH && screen -dmS $SCREEN $INVOCATION"
	as_user "screen -list | grep "\.$SCREEN" | cut -f1 -d'.' | head -n 1 | tr -d -c 0-9 > $pidfile"

	#
	# Waiting for the server to start
	#
	seconds=0
	until is_running
	do
		sleep 1
		seconds=$seconds+1
		if [[ $seconds -eq 5 ]]
		then
			echo_info "Still not running, waiting a while longer..."
		fi
		if [[ $seconds -ge 120 ]]
		then
			echo_err "Failed to start, aborting."
			exit 1
		fi
	done
	echo_out "$SERVICE is running."
}



########
# Passes a string to the Server Jar, as a command
#
# Globals
#	SCREEN		Name of Screen session to command
#
# Arguments
#	1			String to say
#
# Returns
#	0|1
########
mc_command() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	if [ 1 -ne $# ]; then
		echo_err "Can't find command; quitting";
		return 1;
	fi;
	if [ -z "$1" ]; then
		echo_err "Command ($1) is empty; quitting";
		return 1;
	fi;


	as_user "screen -p 0 -S $SCREEN -X stuff \"$1\"\\\015" || return 1;


	return 0;
}


mc_saveoff() {
	if is_running
	then
		echo_out "$SERVICE is running... suspending saves"
		mc_command save-off
		mc_command save-all
		sync
		sleep 10
	else
		echo_info "$SERVICE was not running. Not suspending saves."
	fi
}


mc_saveon() {
	if is_running
	then
		echo_out "$SERVICE is running... re-enabling saves"
		mc_command save-on
	else
		echo_out "$SERVICE was not running. Not resuming saves."
	fi
}



########
# Broadcasts a message in-game
#
# Globals
#	None
#
# Arguments
#	1		String to say
#
# Returns
#	0|1
########
mc_say() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	if [ -z "$1" ]; then
		echo_err "Message ($1) is empty; quitting";
		return 1;
	fi;


	mc_command "say $1" || return 1;
	echo_out "Said: $1";


	return 0;
}


mc_stop() {
	pidfile=${MCPATH}/${SCREEN}.pid
	#
	# Stops the server
	#
	echo_info "Saving worlds..."
	mc_command save-all
	sleep 10
	echo_out "Stopping server..."
	mc_command stop
	sleep 0.5
	#
	# Waiting for the server to shut down
	#
	seconds=0
	isInStop=1
	while is_running
	do
		sleep 1
		seconds=$seconds+1
		if [[ $seconds -eq 5 ]]
		then
			echo_info "Still not shut down, waiting a while longer..."
		fi
		if [[ $seconds -ge 120 ]]
		then
			logger -t minecraft-init "Failed to shut down server, aborting."
			echo_err "Failed to shut down, aborting."
			exit 1
		fi
	done
	as_user "rm $pidfile"
	unset isInStop
	is_running
	echo_out "$SERVICE is now shut down."
}


mc_reload() {
        echo_out "$SERVICE is running... reloading."
        mc_command reload
}


check_backup_settings() {
	case "$BACKUPFORMAT" in
		tar)
			COMPRESSCMD="tar -hcjf"
			STORECMD="tar -cpf"
			ARCHIVEENDING=".tar.bz2"
			STOREDENDING=".tar"
			EXCLUDEARG="-X "
			;;


		zip)
			COMPRESSCMD="zip -rq"
			STORECMD="zip -rq -0"
			ARCHIVEENDING=".zip"
			STOREDENDING=".zip"
			EXCLUDEARG="-x@"
			;;


		*)
			echo_err "$BACKUPFORMAT is not a supported backup format"
			exit 1
			;;


	esac
}


log_roll() {
	# Moves the logfiles and compresses that backup directory
	check_backup_settings
	path=`datepath $LOGPATH/logs_ $ARCHIVEENDING`
	as_user "mkdir -p $path"

	shopt -s extglob
	for FILE in $(ls $MCPATH/*.log)
	do
		as_user "cp $FILE $path"
		# only if previous command was successful
		if [ $? -eq 0 ]; then
			if [[ "$FILE" = @(*-+([0-9]).log) && "$FILE" = !(*-0.log) ]]
			# some mods already roll logs. remove all but the most recent file
			# which ends with -0.log
			then
				as_user "rm $FILE"
			else
			# truncate the existing log without restarting server
				as_user "cp /dev/null $FILE"
				as_user "echo \"Previous logs rolled to $path\" > $FILE"
			fi
		else
			echo_err "Failed to rotate log from $FILE into $path"
		fi
	done

	as_user "$COMPRESSCMD $path$ARCHIVEENDING $path"
	if [ $? -eq 0 ]; then
		as_user "rm -r $path"
	fi
}


get_worlds() {
	SAVEIFS=$IFS
	IFS=$(echo -en "\n\b")

	a=1
	for NAME in $(ls $WORLDSTORAGE)
	do
		if [ -d $WORLDSTORAGE/$NAME ]
		then
			WORLD_NAMES[$a]=$NAME
			if [ -e $WORLDSTORAGE/$NAME/ramdisk ]
			then
				WORLD_RAM_STATES[$a]=true
			else
				WORLD_RAM_STATES[$a]=false
			fi
			a=$a+1
		fi
	done

	IFS=$SAVEIFS
}


mc_whole_backup() {
	check_backup_settings
	echo_out "backing up entire setup into $WHOLEBACKUP"
	path=`datepath $WHOLEBACKUP/mine_`
	locationOfScript=$(dirname "$(readlink -e "$0")")
	as_user "mkdir -p $path"

	if [ -r "$locationOfScript/exclude.list" ]
	then
		echo_out "...except the following files and/or dirs:"
		cat $locationOfScript/exclude.list
		exclude="$EXCLUDEARG$locationOfScript/exclude.list"
	fi
	if [ "$COMPRESS_WHOLEBACKUP" ]
	then
		as_user "$COMPRESSCMD $path/whole-backup$ARCHIVEENDING $MCPATH $exclude"
	else
		as_user "$STORECMD $path/whole-backup$STOREDENDING $MCPATH $exclude"
	fi
}


mc_world_backup() {
	#
	# Backup the worlds and puts them in a folder for each day (unless $BACKUPSCRIPTCOMPATIBLE is set)
	#

	check_backup_settings
	get_worlds || return 1;
	today="`date +%F-%H-%M-%S`"
	as_user "mkdir -p $BACKUPPATH"

	# Check if the backup script compatibility is enabled
	if [ "$BACKUPSCRIPTCOMPATIBLE" ]
	then
		# If it is enabled, then delete the old backups to prevent errors
		echo_out "Detected that backup script compatibility is enabled, deleting old backups that are not necessary."
		as_user "rm -r $BACKUPPATH/*"
	fi


	## declare vars
	local index world_name;


	for index in "${!WORLD_NAMES[@]}"; do
		world_name="${WORLD_NAMES[$INDEX]}";


		echo_out "Backing up minecraft $world_name";


		# If this is set tars will be created compatible to WorldEdit
		if [ "$WORLDEDITCOMPATIBLE" ]; then
			as_user "mkdir -p $BACKUPPATH/$world_name";
			path="$(datepath $BACKUPPATH/$world_name/ $ARCHIVEENDING $ARCHIVEENDING)";


		# If is set tars will be put in $BACKUPPATH without any timestamp to be compatible with
		# [backup rotation script](https://github.com/adamfeuer/rotate-backups)
		elif [ "$BACKUPSCRIPTCOMPATIBLE" ]; then
			path="$BACKUPPATH/$world_name$ARCHIVEENDING";


		else
			as_user "mkdir -p $BACKUPPATH/${today}";
			path="$(datepath $BACKUPPATH/${today}/$world_name_ $ARCHIVEENDING $ARCHIVEENDING)";
		fi;


		# Don't store the complete path
		if [ "$WORLDEDITCOMPATIBLE" ]; then
			as_user "cd $MCPATH && $COMPRESSCMD $path $world_name";
		else
			as_user "$COMPRESSCMD $path $MCPATH/$world_name";
		fi;
	done;


	return 0;
}



########
# Loops through WORLD_NAMES, (re)creating a link for each world in $MCPATH
#
# Globals
#	MCPATH				Path to the server jar; where symlinks-to-worlds should be created
#	WORLD_NAMES			List of world-names
#	WORLD_RAM_STATES	Boolean list of whether each world should use the ram-disk
#	WORLDSTORAGE		Where, on disk, games are saved
#
# Arguments
#	None
#
# Returns
#	0		Success
#	1		Failure
########
function symlink_worlds_inside_MCPATH() {
	get_worlds || return 1;


	## declare vars
	local index link world_name world_ram_state;


	echo_debug "WORLD_NAMES ${WORLD_NAMES[*]}";
	for index in "${!WORLD_NAMES[@]}"; do
		echo_debug "index $index";
		echo_debug "WORLD_NAMES ${WORLD_NAMES[$index]}";


		world_name="${WORLD_NAMES[$index]}";
		echo_debug "world_name $world_name";


		## if there's something wrong with the (non-)link, crash
		## L := symlink
		## e := exists
		if [[ -e "$MCPATH/$world_name" && ! -L "$MCPATH/$world_name" ]]; then
			echo_err "Could not process the world named '$world_name'. Please move all worlds to ${WORLDSTORAGE}. Crashing";
			exit 1;
		fi;


		## if we've already got a symlink, see where it points
		link="$(readlink "$MCPATH/$world_name")";
		echo_debug "link $link";


		world_ram_state="${WORLD_RAM_STATES[$index]}";
		echo_debug "world_ram_state $world_ram_state";
		if ${world_ram_state}; then
			if [ "$link" != "$RAMDISK/$world_name" ]; then
				as_user "rm -f $MCPATH/$world_name";
				as_user "ln -s $RAMDISK/$world_name $MCPATH/$world_name";
				echo_out "Created link for World '$world_name'";
			fi;
		else
			if [ "$link" != "${WORLDSTORAGE}/$world_name" ]; then
				as_user "rm -f $MCPATH/$world_name";
				as_user "ln -s ${WORLDSTORAGE}/$world_name $MCPATH/$world_name";
				echo_out "Created link for World '$world_name'";
			fi;
		fi;
	done;


	return 0;
}


to_ram() {
	get_worlds || return 1;


	## declare vars
	local index world_name;


	for index in "${!WORLD_NAMES[@]}"; do
		world_name="${WORLD_NAMES[$INDEX]}";


		if ${WORLD_RAM_STATES[$INDEX]}; then
			if [ ! -L "$MCPATH/$world_name" ]; then
				continue;
			fi;


			as_user "mkdir -p $RAMDISK"
			as_user "rsync -rt --exclude 'ramdisk' ${WORLDSTORAGE}/$world_name/ $RAMDISK/$world_name"
			echo_out "World '$world_name' copied to ram"
		fi;
	done;


	return 0;
}


to_disk() {
	get_worlds || return 1;


	## declare vars
	local index world_name;


	for index in "${!WORLD_NAMES[@]}"; do
		world_name="${WORLD_NAMES[$INDEX]}";


		if ${WORLD_RAM_STATES[$INDEX]}; then
			as_user "rsync -rt --exclude 'ramdisk' $MCPATH/$world_name/ ${WORLDSTORAGE}/$world_name"
			echo_out "World '$world_name' copied to disk"
		fi;
	done;


	return 0;
}



########
# Fetches the appropriate Jar and compares it to the current one
#
# Globals
#	FLAVOUR		Are we running vanilla MineCraft? Other?
#
# Arguments
#	None
#
# Returns
#	0			Success; upgrade needed
#	1			Failure
#	2			Success; upgrade NOT needed
########
function check_upgrade() {

	## check Flavour; call sub-function; return from sub-function
	echo_debug "FLAVOUR $FLAVOUR";
	case "$FLAVOUR" in
		'vanilla')
			is_vanilla_upgrade_available;
			return $?;
			;;


		'bukkit')
			is_craftbukkit_upgrade_available;
			return $?;
			;;


		## handle unrecognised Flavour
		*)
			echo_err "Flavour ('$FLAVOUR') should be 'vanilla' or 'bukkit'; quitting";
			return 1;
			;;
	esac;


	## we should never reach here
	return 1;
}



########
# Scrape the official download page, looking for $MC_JAR. If found, check version.
#
# Globals
#	MC_DOWNLOAD_PAGE	Page to scrape
#	MC_JAR				File to find
#	MC_PATH				Where to find the old, and put the new, Jar
#
# Arguments
#	None
#
# Returns
#	0		Success; upgrade needed
#	1		Failure
#	2		Success; upgrade NOT needed
########
function is_vanilla_upgrade_available() {
	local basename url;


	## find the name of the latest version
	echo_out "Scraping official page for download link...";
	echo_debug "MC_DOWNLOAD_PAGE $MC_DOWNLOAD_PAGE";
	url="$(wget -q -O - "$MC_DOWNLOAD_PAGE" | grep --perl-regexp --only-matching --regexp='(?<=href=")http[^"]*minecraft_server[^"]*\.jar(?=")')";
	echo_out "...done";
	echo_debug "url $url";

	basename="$(basename "$url")";
	echo_debug "basename $basename";


	## if we've not got the latest version, fetch
	echo_debug "MCPATH $MCPATH";
	if [ ! -f "$MCPATH/$basename" ]; then
		echo_out "Fetching Jar from official page...";
		as_user "wget -q -O \"$MCPATH/$basename\" \"$url\" >/dev/null";
		echo_out "...done";
	fi;
	if [ ! -f "$MCPATH/$basename" ]; then
		echo_err "Failed to fetch latest Jar; quitting";
		return 1;
	fi;


	## if running latest, no upgrade needed
	if ( diff "$MCPATH/$MC_JAR" "$MCPATH/$basename" >/dev/null ); then
		echo_info "You are already running the latest version of $MC_JAR";
		return 2;
	fi;


	echo_out "Upgrade available";
	return 0
}



########
# Output the URL of the latest CraftBukkit JAR
#
# Globals
#	CB_DOWNLOAD_URL		URL of remote craftbukkit.jar. Optionally: with $CB_RELEASE replaced with 'RELEASE'
#	CB_RELEASE			Branch to download, e.g. unstable, beta, stable
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout				URL of file
########
function echo_cb_release_channel() {
	local url="$CB_DOWNLOAD_URL";


	case "$CB_RELEASE" in
		unstable|UNSTABLE|Unstable|dev|development)
			url=${url/RELEASE/dev};
			;;


		beta|Beta|BETA)
			url=${url/RELEASE/beta};
			;;


		*)
			url=${url/RELEASE/rb};
			;;


	esac;


	echo_quiet "$url";

	return 0;
}



########
# CraftBukkit is dead; throw an error
#
# See
#	https://bukkit.org/threads/bukkit-is-permanently-dead-heres-why.312799/
########
# Fetch the current Jar, compare to $CB_JAR, and report the result
#
# Globals
#	CB_JAR			Name of the Craft Bukkit jar-file
#	CB_RELEASE		Which channel to follow (e.g. Alpha)
#	MCPATH			Where to find old and new versions of $CB_JAR on this server
#
# Arguments
#	None
#
# Returns
#	0				Upgrade available
#	1				Failure OR no upgrade available
#
# ToDo
#	Return as per is_upgrade_available()
########
function is_craftbukkit_upgrade_available() {
	echo_err "The CraftBukkit project is dead, as of 2014; upgrades are no longer supported. Crashing";
	exit 1;


#	echo_info "Checking for upgrade for craftbukkit.jar";
#	echo_info "You are on release channel \"$CB_RELEASE\"";
#
#
#	# fetch the JAR from echo_cb_release_channel()
#	as_user "cd $MCPATH && wget -q -O $MCPATH/craftbukkit.latest.jar $(echo_cb_release_channel)";
#
#
#	# if no downloaded file, quit
#	if [ ! -r "$MCPATH/craftbukkit.latest.jar" ]; then
#		echo_err "Something went wrong. Couldn't download craftbukkit.jar; quitting";
#		return 1;
#	fi;
#
#
#	# if no change, quit
#	if ( diff "$MCPATH/$CB_JAR" "$MCPATH/craftbukkit.latest.jar" >/dev/null ); then
#		echo_out "You are already running the latest version of craftbukkit.jar";
#		return 1;
#	fi;
#
#
#	# output
#	echo_out "Upgrade of $CB_JAR is needed";
#
#
#	return 0
}



########
# Upgrades the server-jar to latest version
#
# Globals
#	CB_JAR		Filename of Craftbukkit jar
#	MCPATH		Where to find/put the Jar
#	MC_JAR		Filename of Vanilla jar
#
# Arguments
#	None
#
# Returns
#	0			Success
#	1			Failure
########
function jar_upgrade() {
	if is_running; then
		echo_err "Server is running! Cannot upgrade; quitting";
		return 1;
	fi;


	if is_vanilla_upgrade_available; then
		if [ ! -r "$MCPATH/minecraft_server.latest.jar" ]; then
			echo_err "Can't find/read downloaded upgrade; quitting";
			return 1;
		fi;
		as_user "mv $MCPATH/minecraft_server.latest.jar $MCPATH/$MC_JAR";
		echo_out "Thats it. Upgrade of $MC_JAR done";
	else
		echo_out "Not upgrading $MB_JAR; it's not necessary";
		as_user "rm $MCPATH/minecraft_server.latest.jar";
	fi;


	if is_craftbukkit_upgrade_available; then
		if [ ! -r "$MCPATH/craftbukkit.latest.jar" ]; then
			echo_err "Can't find/read downloaded upgrade; quitting";
			return 1;
		fi;
		as_user "mv $MCPATH/craftbukkit.latest.jar $MCPATH/$CB_JAR";
		echo_out "Thats it. Upgrade of $CB_JAR done";
	else
		echo_out "Not updating $CB_JAR. It's not necessary";
		as_user "rm $MCPATH/craftbukkit.latest.jar";
	fi;


	return 0;
}


change_ramdisk_state() {
	if [ ! -e $WORLDSTORAGE/$1 ]
	then
		echo_err "World \"$1\" not found."
		exit 1
	fi

	if [ -e $WORLDSTORAGE/$1/ramdisk ]
	then
		rm $WORLDSTORAGE/$1/ramdisk
		echo_out "Removed ramdisk flag from \"$1\""
	else
		touch $WORLDSTORAGE/$1/ramdisk
		echo_out "Added ramdisk flag to \"$1\""
	fi
	echo_out "Changes will only take effect after server is restarted."
}


overviewer_start() {
		if [ ! -e $OVPATH/overviewer.py ]
		then
				if [ ! "$OVPATH" == "apt" ]
				then
						echo_err "Minecraft-Overviewer is not installed in \"$OVPATH\""
						exit 1
				else
						echo_out "Using APT repository installed Minecraft-Overviewer"
				fi
		fi
		if [ ! -e $OUTPUTMAP ]
		then
				as_user "mkdir -p $OUTPUTMAP"
		fi
		if [ -e $OVCONFIGPATH/$OVCONFIGNAME ]
		then
				echo_out "Start generating map with Minecraft-Overviewer..."
				if [ "$OVPATH" == "apt" ]
				then
						as_user "overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME"
				else
						as_user "python $OVPATH/overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME"
				fi
				echo_out "Map generated."
		else
				echo_err "No config file found. Start with default config..."
				if [ -z $1 ] || [ ! -e $OVBACKUP/$1 ]
				then
						echo_err "World \"$1\" not found."
				else
						echo_out "Start generating map with Minecraft-Overviewer..."
						if [ "$OVPATH" == "apt" ]
						then
								as_user "nice overviewer.py $OVBACKUP/$1 $OUTPUTMAP"
						else
								as_user "nice python $OVPATH/overviewer.py $OVBACKUP/$1 $OUTPUTMAP"
						fi
						echo_out "Map generated."
				fi
		fi
}



########
# Backup the worlds for overviewer
########
overviewer_copy_worlds() {
	get_worlds || return 1;


	## declare vars
	local index world_name;


	for index in "${!WORLD_NAMES[@]}"; do
		world_name="${WORLD_NAMES[$INDEX]}";

		echo_out "Copying minecraft $world_name."
		as_user "mkdir -p $OVBACKUP"
		as_user "rsync -rt --delete $WORLDSTORAGE/$world_name $OVBACKUP/$world_name"
	done;

	return 0;
}



########
# Queries the Server for the list of users, then outputs to stdout
#
# Globals
#	SERVERLOG		The file that holds the Server's output
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout			Formated list of users currently connected to the server
########
function echo_connected_players() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	# query server & wait for response
	mc_command list || return 1;
	sleep 1s;


	local players;


	# get the list from log
	players="$(tac "$SERVERLOG" | grep --before-context 1 --max-count 1 'players online' | head -n 1)";
	echo_debug "players=$players";

	if [ -z "$players" ]; then
		echo_err "Can't find connected players in \$SERVER_LOG; quitting";
		return 1;
	fi;


	# remove the log-fluff
	players="${players:33}";


	# handle zero-players
	if [ -z "$players" ]; then
		players='No players connected';
	fi;
	echo_debug "players=$players";


	# change line to list
	players="${players//, /\\n\\t}";


	# print & return
	echo_info	"These players are connected:"
	echo_quiet	"\t$players";
	return 0;
}



########
# Wraps echo_connected_players() to return a count
#
# Globals
#	None
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout			Integer count of players online
########
function echo_playercount() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	local cache=$VERBOSITY;	# cache the current VERBOSITY
	VERBOSITY=$VERBOSITY_QUIET;	# set to known level (quiet)
	local player_list="$(echo_connected_players)";
	VERBOSITY=$cache;	# reset VERBOSITY
	echo_debug "player_list=$player_list";


	# if no users; skip
	if [ 'No users connected' = "$player_list" ]; then
		echo_quiet 0;
		return 0;
	fi;


	# count the words (usernames); output
	echo_info	"There are this many players online:";
	echo_quiet	"$(echo "$player_list" | wc -w)";


	return 0;
}



########
# Checks server-log for recent player activity
#
# Globals
#	SERVERLOG	File containing player activity
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout		Formatted list of recent player activity
########
function echo_recent_players() {
	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	# get the log & filter for player activity
	echo_debug "SERVERLOG=$SERVERLOG";
	if [ ! -f "$SERVERLOG" ]; then
		echo_err "Can't find \$SERVERLOG ($SERVERLOG); quitting";
		return 1;
	fi;
	local log="$(cat $SERVERLOG | grep 'joined the game\|left the game')";
	echo_debug "log=$log";


	# format for display
	log="${log// \[Server thread\/INFO\]/}";
	if [ -z "$log" ]; then
		log="No recent players";
	fi;
	echo_debug "log=$log";


	# output
	echo_info "Recently player activity:";
	echo_quiet "$log";


	return 0;
}



########
# Queries the Server Jar for the whitelist, then returns it
#
# Globals
#	SERVERLOG	File that holds the server's output
#
# Arguments
#	None
#
# Returns
#	0|1
########
echo_whitelist(){
	# query server and wait for reply
	mc_command "whitelist list" || return 1;
	sleep 1s;

	local whitelist;

	# extract data from log
	whitelist="$(tac "$SERVERLOG" | grep -m 1 -B 1 'whitelisted players:' | head -n 1)";
	whitelist="${whitelist:33}";			# remove the log-fluff
	whitelist="${whitelist// and /, }";		# remove ' and '
	whitelist="${whitelist//, /\\n\\t}";	# change line to list

	# Pre MC v1.8.8
	if [ -z "$whitelist" ]; then
		whitelist="$(tac "$SERVERLOG" | grep -m 1 'White-listed players:')";
		whitelist="${whitelist:49}";	# remove the log-fluff
		whitelist="${whitelist//, /\n}";	# change line to list
	fi;

	echo_out	"Your whitelist is:"
	echo_quiet	"\t$whitelist";

	return 0;
}


force_exit() {  # Kill the server running (messily) in an emergency
	echo_out ""
	echo_out "SIGINIT CALLED - FORCE EXITING!"
	pidfile=${MCPATH}/${SCREEN}.pid
	rm $pidfile
	echo_out "KILLING SERVER PROCESSES!!!"
		# Display which processes are being killed
		ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}
		ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}
		ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}

		# Kill the processes
		ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i kill {}
		ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i kill {}
		ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i kill {}

	exit 1
}


get_script_location() {
	echo_quiet $(dirname "$(readlink -e "$0")")
}


check_permissions() {
	as_user "touch $pidfile"
	if ! as_user "test -w '$pidfile'" ; then
		echo_err "Check Permissions. Cannot write to $pidfile. Correct the permissions and then excute: $0 status"
	fi
}



########
# Decide with function(s) to call, based on commandline call
#
# Globals
#	INIT_COMMAND		(Main) command to run
#	INIT_SUBCOMMAND		Variant of <command> to run
#
# Arguments
#	@					All parameters, to pass to e.g. redirect functions
#
# Returns
#	0|1
########
function route_command() {
	echo_debug "@=$*";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";


	## declare vars
	local index;


	case "$INIT_COMMAND" in
		start)
			# Starts the server
			if is_running; then
				echo_out "Server already running."
			else
				symlink_worlds_inside_MCPATH || return 1;
				to_ram
				mc_start
			fi
			;;


		stop)
			# Stops the server
			if is_running; then
				mc_say "SERVER SHUTTING DOWN!"
				mc_stop
				to_disk
			else
				echo_out "No running server."
			fi
			;;


		restart)
			# Restarts the server
			if is_running; then
				mc_say "SERVER REBOOT IN 10 SECONDS!"
				mc_stop
				to_disk
			else
				echo_out "No running server, starting it..."
			fi
			symlink_worlds_inside_MCPATH || return 1;
			to_ram
			mc_start
			;;
			reload)
					# Reloads server configuration
					if is_running; then
							mc_say "Reloading server configuration.."
							mc_reload
					else
							echo_out "No running server."
					fi
					;;


		whitelist)
			if is_running; then
				echo_whitelist || return 1;
			else
				echo_out "Server not running."
			fi
			;;


		whitelist-reload)
			# Reloads the whitelist
			if is_running; then
				mc_command "whitelist reload"
			else
				echo_out "No running server."
			fi
			;;


		whitelist-add)
			# Adds a player to the whitelist
			if is_running; then
				mc_command "whitelist add $INIT_SUBCOMMAND"
			else
				echo_out "No running server."
			fi
			;;


		backup)
			# Backups world
			if is_running; then
				mc_say "Backing up world."
				mc_saveoff
				to_disk
				mc_world_backup
				mc_saveon
				mc_say "Backup complete."
			else
				mc_world_backup
			fi
			;;


		whole-backup)
			# Backup everything
			if is_running; then
				mc_say "COMPLETE SERVER BACKUP IN 10 SECONDS.";
				mc_say "WARNING: WILL RESTART SERVER SOFTWARE!"
				mc_stop
				to_disk
				mc_whole_backup
				symlink_worlds_inside_MCPATH || return 1;
				mc_start
			else
				mc_whole_backup
			fi
			;;


		check-update)
			echo_err "Deprecated; use '$SELF check-upgrade' instead";
			return 1;
			;;


		check-upgrade)
			check_upgrade || return 1;
			;;


		update)
			echo_err "Deprecated; use '$SELF upgrade' instead";
			return 1;
			;;


		#upgrade minecraft_server.jar and craftbukkit.jar (thanks karrth)
		upgrade)
			if is_running; then
				mc_say "SERVER UPGRADE IN 10 SECONDS."
				mc_stop
				to_disk
				mc_whole_backup
				jar_upgrade
				symlink_worlds_inside_MCPATH || return 1;
				mc_start
			else
				mc_whole_backup
				jar_upgrade
			fi
			;;


		to-disk)
			# Writes from the ramdisk to disk, in case the server crashes.
			mc_saveoff
			to_disk
			mc_saveon
			;;


		save-off)
			# Flushes the state of the world to disk, and then disables
			# saving until save-on is called (useful if you have your own
			# backup scripts).
			if is_running; then
				mc_saveoff
			else
				echo_out "Server was not running, syncing from ram anyway..."
			fi
			to_disk
			;;


		save-on)
			# Re-enables saving if it was disabled by save-off.
			if is_running; then
				mc_saveon
			else
				echo_out "No running server."
			fi
			;;


		say)
			# Says something to the ingame chat
			if is_running; then
				shift 1
				mc_say "$INIT_SUBCOMMAND"
			else
				echo_out "No running server to say anything."
			fi
			;;


		command)
			if is_running; then
				shift 1
				mc_command "$INIT_SUBCOMMAND"
				echo_out "Sent command: \"$INIT_SUBCOMMAND\"";
			else
				echo_out "No running server to send a command to."
			fi
			;;


		connected)
			echo_connected_players || return 1;
			;;


		playercount)
			echo_playercount || return 1;
			;;


		log-roll)
			log_roll
			;;


		log)
			# Display server log using 'cat'.
			cat $SERVERLOG
			;;


		last)
			echo_recent_players || return 1;
			;;


		status)
			# Shows server status
			if is_running
			then
				echo_quiet "$SERVICE is running."
			else
				echo_quiet "$SERVICE is not running."
			fi
			;;


		watchdog)
			# Ensures server is still running
			if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
			then
				echo_out "$SERVICE is running."
			else
				mc_stop
				mc_start
			fi
			;;


		## @todo	Fix: Vanilla doesn't understand "version"
		version)
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi;

			if [ "$SERVICE" != "$CB_JAR" ]; then
				echo_out "'$SELF $INIT_COMMAND' only works on CraftBukkit servers; skipping";
				return 0;
			fi;

			mc_command 'version' || return 1;
			tac "$SERVERLOG" | grep -m 1 "This server is running" || return 1;
			;;


		links)
			echo_err "'$SELF links' is deprecated; use '$SELF link-worlds'; quitting";
			return 1;
			;;


		'link-worlds')
			symlink_worlds_inside_MCPATH || return 1;
			echo_out "Re-built links to saved worlds";
			;;


		ramdisk)
			change_ramdisk_state $INIT_SUBCOMMAND
			;;


		worlds)
			get_worlds || return 1;
			for index in "${!WORLD_NAMES[@]}"; do
				if ${WORLD_RAM_STATES[$index]}; then
					echo_quiet "${WORLD_NAMES[$index]} (ramdisk)";
				else
					echo_quiet "${WORLD_NAMES[$index]}";
				fi;
			done;
			;;


		overviewer)
			if is_running; then
				mc_say "Generating overviewer map."
				mc_saveoff
				to_disk
				overviewer_copy_worlds
				mc_saveon
				overviewer_start $INIT_SUBCOMMAND
			else
				overviewer_copy_worlds
				overviewer_start $INIT_SUBCOMMAND
			fi
			;;


		screen)
			if is_running; then
				as_user "script /dev/null -q -c \"screen -rx $SCREEN\""
			else
			echo_info "Server is not running. Do you want to start it?"
			echo_quiet "Please put \"Yes\", or \"No\": "
			read START_SERVER
			case "$START_SERVER" in
				[Yy]|[Yy][Ee][Ss])
					symlink_worlds_inside_MCPATH || return 1;
					to_ram
					mc_start
					as_user "script /dev/null -q -c \"screen -rx $SCREEN\""
					;;


				[Nn]|[Nn][Oo])
					clear
					echo_err "Aborting startup!"
					sleep 1
					clear
					exit 1
					;;


				*)
					clear
					echo_err "Invalid input"
					sleep 1
					clear
					exit 1
					;;


			esac
			fi
			;;


		kill)
			WIDTH=`stty size | cut -d ' ' -f 2`            # Get terminal's character width
			pstree | grep MDSImporte | cut -c 1-${WIDTH}   # Chop output after WIDTH chars

			echo_out "Killing the server is an EMERGENCY procedure, and should not be used to perform a normal shutdown! All changes younger than 15 minutes could be permanantly lost and WORLD CORRUPTION is possible! Are you ABSOLUTELY POSITIVE this is what you want to do?"
			echo_quiet "Please put \"Yes\", or \"No\": "
			read KILL_SERVER
			case "$KILL_SERVER" in  # Determine which option was specified
				[Yy]|[Yy][Ee][Ss])      # If yes, kill the server
					echo_err "KILLING SERVER PROCESSES!!!"
					force_exit
					exit 1
					;;


				[Nn]|[Nn][Oo])  # If no, abort and exit 1
					echo_err "Aborting!"
					exit 1
					;;


				*)      # If anything else, exit 1
					echo_err "Error: Invalid Input!"
					exit 1
					;;


			esac
			;;


		help|--help|-h)
			echo_usage;
			;;


		mci-version|mci_version|script-version|script_version)
			echo_mci_version;
			;;


		*)
			echo_err "No such command as '$SELF $INIT_COMMAND'; quitting";
			echo;
			echo_usage;
			exit 1
			;;
	esac


	return 0;
}



########
# Reads commandline parameters, loads the config, and runs the command
########
function main() {
	## read commandline options
	handle_commandline_options "$@" || return 1;

	## load defaults & user config
	config_load || return 1;

	## run the command
	route_command "$@" || return 1;	# need to inject $@ so route_command() can pass it on

	return 0;
}



###############################################################################
## Run, tidy, quit
###############################################################################

trap force_exit SIGINT
main "$@" || exit 1;
exit 0;
