#!/bin/bash
# /etc/init.d/minecraft

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Init script for minecraft/bukkit server, with rolling logs and use of ramdisk for less lag.
### END INIT INFO

# Created by Ahtenus

# Based on http://www.minecraftwiki.net/wiki/Server_startup_script
# Support for multiworld by Benni-chan
# Log rolls without needing restarts by Solorvox
# Option for killing server in an emergency by jbondhus



###############################################################################
## Bootstrap
###############################################################################

set -u;	# error on undeclared var
set -e;	# exit on error



###############################################################################
## Define constants
###############################################################################


## name of the current script
export readonly SELF="$(basename "$0")";


## Quiet		:= no output
readonly export VERBOSITY_QUIET=-1;


## Default		:= success messages; etc
readonly export VERBOSITY_DEFAULT=0;


## Info			:= values of subshells; function-calls, in prose
readonly export VERBOSITY_INFO=1;


## Verbose		:= final value of vars, in prose
readonly export VERBOSITY_VERBOSE=2;


## Debugging	:= all possible outputs, tersely
readonly export VERBOSITY_DEBUG=3;



###############################################################################
## Init vars
###############################################################################


## default location of config [same dir as $0]
export CONFIG_FILE="$(dirname "$(readlink -e "$0")")/config";


## indexed list of saved worlds
export WORLDNAME=();


## indexed list of bools (ramdisk on|off)
export WORLDRAM=();


## Level of debugging-info to output
export VERBOSITY=$VERBOSITY_DEFAULT;



###############################################################################
## Functions
###############################################################################



########
# Output the current version of MineCraft-Init
########
function echo_mci_version() {
	echo_quiet '2.7.2';
	return 0;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#	VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Verbosity-level, e.g. VERBOSITY_QUIET
#	2	Message
#
# Returns
#	0					On success
#	1					On failure
########
function echo_by_level() {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Verbosity-level is not an integer; quitting";
		return 1;
	fi;


	# if this message is verbose, but we're quieter, stop here
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	local message="$2";


	# if debugging, prefix with function
	if [ "$1" -ge "$VERBOSITY_DEBUG" ]; then
		message="[${FUNCNAME[2]}] $message";
	fi;


	# put to stdout
	echo -e "$message";


	return 0;
}


## wrappers for echo_by_level
function echo_quiet()	{ echo_by_level "$VERBOSITY_QUIET"		"${1-}";	return $?; }
function echo_out()		{ echo_by_level "$VERBOSITY_DEFAULT"	"${1-}";	return $?; }
function echo_info()	{ echo_by_level "$VERBOSITY_INFO"		"${1-}";	return $?; }
function echo_verbose()	{ echo_by_level "$VERBOSITY_VERBOSE"	"${1-}";	return $?; }
function echo_debug()	{
	local status=0;

	echo_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;
	log_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;

	return $status;
}



########
# Send errors to stderr
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo()
########
function echo_err() {
	echo -e "$@" 1>&2;
	return $?;
}



########
# Send errors to stderr
#
# DEPRECATED by echo_err()
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo_err()
########
function echoerr() {
	echo_err "echoerr() is deprecated; use echo_err() instead";
	echo_err "$@";
	return $?;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#	VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Log-level := VERBOSITY_QUIET <-> VERBOSITY_DEBUG
#	2	Message
#
# Returns
#	0					On success
#	1					On failure
########
function log_by_level() {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Log-level is not an integer; quitting";
		return 1;
	fi;


	# if we're too quiet to show the message, finish
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	# if can't write to file, crash
	if [ ! -f "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't find latest.log in $MCPATH/logs/; crashing";
		exit 1;
	fi;
	if [ ! -w "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't write to $MCPATH/logs/latest.log; crashing";
		exit 1;
	fi;


	# log to file -- with date, level, function
	local function_name="${FUNCNAME[1]}";	# get calling function
	function_name="${function_name#log_}";	# if log_foo, remove prefix
	function_name="${function_name#echo_}";	# if echo_foo, remove prefix
	echo "[$(date +%Y-%m-%d:%H:%M:%S)] [$function_name] [${FUNCNAME[2]}] $2" >> "$MCPATH/logs/latest.log";


	return 0;
}


## wrappers for log_by_level
function log_quiet()	{ log_by_level "$VERBOSITY_QUIET" "$1";		return $?; }
function log()			{ log_by_level "$VERBOSITY_DEFAULT" "$1";	return $?; }
function log_info()		{ log_by_level "$VERBOSITY_INFO" "$1";		return $?; }
function log_verbose()	{ log_by_level "$VERBOSITY_VERBOSE" "$1";	return $?; }
function log_debug()	{ log_by_level "$VERBOSITY_DEBUG" "$1"; 	return $?; }



########
# Output details of supported commands
#
# Globals
#	SELF	Name of this script
#
# Arguments
#	None
#
# Returns
#	0		On success
#	1		On failure
########
function echo_usage() {
	echo_quiet "Usage: $SELF [<options>] <command>";
	echo_out;
	echo_out "Where <options> is zero or more of:";
	echo_out "   -c <file>  Config. Loads the given config file. Default is $(dirname "$0")/config";
	echo_out "   -q	        Quiet. Decreases the script's verbosity";
	echo_out "   -v	        Verbose. Increases the script's verbosity. May be repeated. Max is three";
	echo_out;
	echo_out "Where <command> is one of:";
	echo_out "   start \t\t Starts the server";
	echo_out "   stop \t\t Stops the server";
	echo_out "   kill \t\t Kills the server";
	echo_out "   restart \t\t Restarts the server";
	echo_out "   watchdog \t Ensures server is still running";
	echo_out "   reload \t\t Reloads the server configuration";
	echo_out "   backup \t\t Backups the worlds defined in the script";
	echo_out "   whole-backup \t Backups the entire server folder";
	echo_out "   check-update \t Checks for updates of $CB_JAR and $MC_JAR";
	echo_out "   update \t\t Fetches the latest version of minecraft.jar server and Bukkit";
	echo_out "   log-roll \t\t Moves and compresses the logfiles";
	echo_out "   log \t\t\t Prints the server log";
	echo_out "   to-disk \t\t Copies the worlds from the ramdisk to worldstorage";
	echo_out "   save-off \t\t Flushes the world to disk and then disables saving";
	echo_out "   save-on \t\t Re-enables saving if it was previously disabled by save-off";
	echo_out "   say \t\t\t Prints the given string to the ingame chat";
	echo_out "   connected \t\t Lists connected users";
	echo_out "   playercount \t\t Prints the number of connected users";
	echo_out "   status \t\t Displays server status";
	echo_out "   version \t\t Displays Bukkit version and then exits";
	echo_out "   links \t\t Creates nessesary symlinks";
	echo_out "   last \t\t Displays recently connected users";
	echo_out "   worlds \t\t Displays a list of available worlds";
	echo_out "   ramdisk WORLD \t Toggles ramdisk configuration for WORLD";
	echo_out "   overviewer WORLD \t Creates a map of the WORLD with Minecraft-Overviewer";
	echo_out "   whitelist \t\t Prints the current whitelist";
	echo_out "   whitelist-add NAME \t Adds the specified player to the server whitelist";
	echo_out "   whitelist-reload \t Reloads the whitelist";
	echo_out "   screen \t\t Shows the server screen";
	echo_out "   script-version	Show this script's version";
	echo_out "   help \t\t Shows this text";

	return 0;
}



########
# Extract commandline parameters from call
#
# Globals
#	CONFIG_FILE			Set by -c
#	INIT_COMMAND		The command to run
#	INIT_SUBCOMMAND		The sub-command to run and/or message to pass, etc
#	VERBOSITY			Incremented by -v; reset by -q
#
# Arguments
#	@					All commandline parameters
#
# Returns
#	0					On success
#	1					On failure
########
function handle_commandline_options() {
	echo_debug "@=$*";
	echo_debug "#=$#";


	OPTIND=1;		# Reset in case getopts has been used previously in the shell.
	while getopts 'c:qv' option; do
		echo_debug "option=$option";

		case "$option" in
			c)	CONFIG_FILE="$(echo "$OPTARG" | xargs)";	# strip whitespace
				;;


			q)	VERBOSITY=$VERBOSITY_QUIET;
				;;


			v)	VERBOSITY=$((VERBOSITY+1));
				;;


			*)	echo_err "Unrecognised parameter '$option'; quitting";
				return 1;
				;;


		esac;
	done;
	echo_debug "CONFIG_FILE=$CONFIG_FILE";
	echo_debug "VERBOSITY=$VERBOSITY";


	shift $((OPTIND-1));	# skip the params we've already processed


	export readonly INIT_COMMAND="${1-}";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";

	export readonly INIT_SUBCOMMAND="${2-}";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";


	return 0;
}



########
# Loads defaults, loads (selected?) config file, and sets derived params
#
# Globals
#	CONFIG_FILE		Location of local config file; used in error message
#	INVOCATION		Command-string to start the server
#	SERVICE			Jar to run; used to test config is loaded
#
# Arguments
#	None
#
# Returns
#	0				On success
#	1				On failure
########
function config_load() {
	## load default config
	config_load_defaults || {
		echo_err "Can't load default config; crashing";
		exit 1;
	}


	## load local config
	config_load_local || {
		echo_err "Can't load local config ($CONFIG_FILE); crashing";
		exit 1;
	}


	## test config is loaded
	if [ -z "$SERVICE" ]; then
		logger -t minecraft-init "Can't load local config ($CONFIG_FILE); crashing";
		exit 1;
	fi


	## set dependant vars
	readonly INVOCATION="java -Xmx$MAXMEM -Xms$INITMEM -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalPacing -XX:ParallelGCThreads=$CPU_COUNT -XX:+AggressiveOpts -jar $SERVICE nogui";


	return 0;
}



########
# Initialises all configs to sensible default values; template for local config file
#
# Globals
#	Lots
#
# Arguments
#	None
#
# Returns
#	0		On success
#	1		On failure
########
function config_load_defaults() {
	## config MineCraft
	MC_JAR="minecraft_server.jar";
	CB_JAR="craftbukkit.jar";
	CB_RELEASE="stable";
	SERVICE="$MC_JAR";
	MCPATH="/usr/lib/minecraft";
	SERVERLOG="${MCPATH}/logs/latest.log";
	WORLDSTORAGE="/var/lib/minecraft/data";

	## config minecraftd
	SCREEN="server_screen";
	USERNAME="minecraft";

	## hardware
	CPU_COUNT=2;
	INITMEM="2048M";
	MAXMEM="2048M";
	RAMDISK="/dev/shm";

	## backups
	BACKUPPATH="${MCPATH}/backup/world";
	WHOLEBACKUP="${MCPATH}/backup/server";
	BACKUPFORMAT="tar";
	BACKUPSCRIPTCOMPATIBLE=YES;
	COMPRESS_WHOLEBACKUP=YES;

	## logging
	# Location for archived logs
	# Used by the log-roll command
	LOGPATH="/var/log/minecraft";

	## config MineCraft-Overviewer
	OUTPUTMAP="/home/${USERNAME}/mc-overviewer/render";
	OVPATH="/home/${USERNAME}/mc-overviewer/Minecraft-Overviewer";
	OVCONFIGPATH="/home/${USERNAME}/mc-overviewer";
	OVCONFIGNAME="config.py";
	OVBACKUP="/home/${USERNAME}/mc-overviewer/overviewerbackups";

	return 0;
}



########
# Loads local config file
#
# Globals
#	CONFIG_FILE		Location of file to load; set at commandline
#
# Arguments
#	None
#
# Returns
#	0		On success
#	1		On failure
########
function config_load_local() {
	## check file exists
	if [ ! -f "$CONFIG_FILE" ] || [ ! -r "$CONFIG_FILE" ] ; then
		echo_err "Couldn't find config file ($CONFIG_FILE); crashing";
		echo_err "Please fix your command and try again, or copy config.example to '$(basename "$CONFIG_FILE")'";
		exit 1;
	fi


	## load file
	source "$CONFIG_FILE" || {
		echo_err "Failed to load config file '$CONFIG_FILE'; crashing";
		exit 1;
	}


	return 0;
}



########
# Runs an arbitrary command as USERNAME
#
# Globals
#	USERNAME
#
# Arguments
#	1		Command to run
#
# Returns
#	0					On success
#	1					On failure
########
function as_user() {
	echo_debug "1=$1";


	if [ 1 -ne $# ] || [ -z "$1" ]; then
		echo_err "Command is missing or invalid; quitting";
		return 1;
	fi;


	local me="$(whoami)";
	echo_debug "me=$me";
	echo_debug "USERNAME=$USERNAME";


	# if we're already USERNAME, run
	if [ "$me" = "$USERNAME" ] ; then
		bash -c "$1" || return 1;
		return 0;
	fi;


	su "$USERNAME" -s /bin/bash -c "$1" || return 1;


	return 0;
}


function is_running() {
	# Checks for the minecraft servers screen session
	# returns true if it exists.
	pidfile=${MCPATH}/${SCREEN}.pid

	if [ -f "$pidfile" ]
	then
		pid=$(head -1 $pidfile)
		if ps ax | grep -v grep | grep ${pid} | grep "${SCREEN}" > /dev/null
		then
			return 0
		else
			if [ -z "$isInStop" ]
			then
				if [ -z "$roguePrinted" ]
				then
					roguePrinted=1
					echo_err "Rogue pidfile found!"
				fi
			fi
			return 1
		fi
	else
		if ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" > /dev/null
		then
			echo_err "No pidfile found, but server's running."
			echo_err "Re-creating the pidfile."

			pid=$(ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" | cut -f1 -d' ')
			check_permissions
			as_user "echo $pid > $pidfile"

			return 0
		else
			return 1
		fi
	fi
}



########
# Generates a path to place the file. If dir-date-ending already exists, it 
# adds a unique integer after the date.
#
# Globals
#	None
#
# Arguments
#	1			Dir (may include trailing slash)
#	2			File ending to check for uniqueness
#	3			File ending to return
#
# Returns
#	0			On success
#	1			On failure
#	stdout		The resulting path
########
function datepath() {

	# -e :- file exists (may be special)
	if [ -e "$1$(date +%F)$2" ]; then
		echo_quiet "$1$(date +%FT%T)$3";
	else
		echo_quiet "$1$(date +%F)$3";
	fi

	return 0;
}


function mc_start() {
	if is_running; then
		return 0;
	fi;

	local servicejar="$MCPATH/$SERVICE";
	if [ ! -f "$servicejar" ]; then
		echo_err "Failed to start: Can't find the specified Minecraft jar under $servicejar. Please check your config!"
		return 1;
	fi

	pidfile="$MCPATH/$SCREEN.pid";
	check_permissions || return 1;

	as_user "cd $MCPATH && screen -dmS $SCREEN $INVOCATION";
	as_user "screen -list | grep \"\.$SCREEN\" | cut -f1 -d'.' | head -n 1 | tr -d -c 0-9 > $pidfile";



	#
	# Waiting for the server to start
	#
	seconds=0
	until is_running; do
		sleep 1
		seconds=$seconds+1

		# wait a little longer...
		if [[ $seconds -eq 5 ]]; then
			echo_info "Still not running, waiting a while longer...";
			continue;
		fi

		# ...then quit
		if [[ $seconds -ge 120 ]]; then
			echo_err "Failed to start; quitting";
			return 1;
		fi
	done

	echo_out "Server is running";

	return 0;
}



########
# Passes a string to the Server Jar, as a command
#
# Globals
#	SCREEN		Name of Screen session to command
#	USERNAME	mc_command() will only run for user $USERNAME
#
# Arguments
#	1			String to say
#
# Returns
#	0			On success
#	1			On failure
########
function mc_command() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_err "Not able to run command as the server is not running; quitting";
		return 1;
	fi


	if [ 1 -ne $# ]; then
		echo_err "Can't find command; quitting";
		return 1;
	fi;
	if [ -z "$1" ]; then
		echo_err "Command ($1) is empty; quitting";
		return 1;
	fi;


	as_user "screen -p 0 -S $SCREEN -X stuff \"$1\"\\\015" || {
		echo_err "Daemon returned error #$? when given '$1'; quitting";
		return 1;
	}


	return 0;
}


function mc_saveoff() {
	if ! is_running; then
		echo_out "Server not running; skipping";
		return 0;
	fi;

	echo_info "Suspending saves...";
	mc_command 'save-off' || return 1;
	mc_command 'save-all' || return 1;
	sync;
	sleep 10;
	echo_out "Saves suspended";

	return 0;
}


function mc_saveon() {
	if ! is_running; then
		echo_out "Server was not running; skipping";
		return 0;
	fi;

	mc_command 'save-on' || return 1;
	echo_out "Saves re-enabled";

	return 0;
}



########
# Broadcasts a message in-game
#
# Globals
#	None
#
# Arguments
#	1		String to say
#
# Returns
#	0		On success
#	1		On failure
########
function mc_say() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	if [ -z "$1" ]; then
		echo_err "Message ($1) is empty; quitting";
		return 1;
	fi;


	mc_command "say $1" || return 1;
	echo_out "Said: $1";


	return 0;
}


# Stops the server
function mc_stop() {
	local pidfile="$MCPATH/$SCREEN.pid";


	# save
	echo_out "Saving worlds...";
	mc_command 'save-all' || return 1;
	sleep 10


	# stop
	echo_out "Stopping server...";
	mc_command 'stop' || return 1;
	sleep 0.5


	#
	# Waiting for the server to shut down
	#
	seconds=0
	isInStop=1
	while is_running; do
		sleep 1;
		seconds=$seconds+1;


		if [ 5 -eq $seconds ]; then
			echo_info "Still not shut down, waiting a while longer..."
		fi;


		if [ 120 -gt $seconds ]; then
			logger -t minecraft-init "Failed to shut down server, aborting";
			echo_err "Failed to shut down, quitting";
			return 1;
		fi
	done


	as_user "rm $pidfile"
	unset isInStop


	is_running && return 1;


	echo_out "$SERVICE is now shut down";
	return 0;
}


function mc_reload() {
	echo_out "$SERVICE is running... reloading";
	mc_command 'reload' || return 1;
	return 0;
}



#######
# Sets various properties, from $BACKUPFORMAT
#
# Globals
#	ARCHIVEENDING	File-extension for compressed files
#	BACKUPFORMAT	From ./config
#	COMPRESSCMD		Shell command to compress files
#	EXCLUDEARG		Parameter $COMPRESSCMD will use to exclude individual files
#	STORECMD		Shell command to copy files
#	STOREDENDING	File-extension for non-compressed files
#
# Arguments
#	None
#
# Returns
#	0				On success
#	1				On failure
#######
function check_backup_settings() {
	case "$BACKUPFORMAT" in
		tar)
			COMPRESSCMD="tar -hcjf"
			STORECMD="tar -cpf"
			ARCHIVEENDING=".tar.bz2"
			STOREDENDING=".tar"
			EXCLUDEARG="-X "
			;;


		zip)
			COMPRESSCMD="zip -rq"
			STORECMD="zip -rq -0"
			ARCHIVEENDING=".zip"
			STOREDENDING=".zip"
			EXCLUDEARG="-x@"
			;;


		*)
			echo_err "$BACKUPFORMAT is not a supported backup format";
			return 1;
			;;


	esac


	return 0;
}



########
# Rotates & compresses the server's log (latest.log) to a named directory and rotates older logs
#
# Globals
#	ARCHIVEENDING	What to name the backup-log; should suit $COMPRESSCMD; set from $BACKUPFORMAT
#	COMPRESSCMD		What to compress the backup-log with; set from $BACKUPFORMAT
#	LOGPATH			Where to put the backup-log, named logs_*
#	MCPATH			Where to find the server-log, e.g. $MCPATH/*.log
#
# Arguments
#	None
#
# Returns
#	0				On success
#	1				On failure
########
function log_roll() {
	check_backup_settings || return 1;


	## init vars
	local path;


	## make a dir for the output
	readonly path="$(datepath "$LOGPATH/logs_" "$ARCHIVEENDING")";
	if [ ! -d "$path" ]; then
		as_user "mkdir -p $path";
	fi;
	if [ ! -d "$path" ]; then
		echo_err "Failed to make $path; quitting...";
		return 1;
	fi;


	## loop over logs in MCPATH/
	shopt -s extglob;
	shopt -s nullglob;	# if no files, loop 0 times
	local file;
	for file in $MCPATH/*.log; do


		## copy
		as_user "cp $file $path" || {
			echo_err "Failed to rotate log from $file into $path; quitting";
			return 1;
		}


		# some mods already roll logs. remove all but the most recent file
		# which ends with -0.log
		if [[ "$file" = @(*-+([0-9]).log) && "$file" = !(*-0.log) ]]; then
			as_user "rm $file";
			continue;
		fi;


		## truncate the existing log without restarting server
		as_user "cp /dev/null $file";
		as_user "echo \"Previous logs rolled to $path\" > $file";
	done;


	## compress
	as_user "$COMPRESSCMD $path$ARCHIVEENDING $path" || {
		echo_err "Failed to compress $path; quitting";
		return 1;
	}


	## tidy
	as_user "rm -r $path" || {
		echo_err "Failed to delete old log from $path; quitting";
		return 1;
	}


	return 0;
}


########
# Loops through the saved worlds, caching names and ramdisk-status
#
# Globals
#	WORLDNAME		Indexed list of world-names
#	WORLDRAM		Indexed list of bools
#	WORLDSTORAGE	Directory holding save-games. From config.
#
# Arguments
#	None
#
# Returns
#	0				On success
#	1				On failure
########
function get_worlds() {
	log_debug "WORLDSTORAGE=$WORLDSTORAGE";
	if [ ! -d "$WORLDSTORAGE" ]; then
		echo_err "Can't find $WORLDSTORAGE; quitting";
		return 1;
	fi;


	## init vars
	local basename name is_ram saveifs;


	## reset globals
	WORLDNAME=();
	WORLDRAM=();


	## handle filenames with spaces
	readonly saveifs="$IFS";	## cache for later
	IFS="$(echo -en "\n\b")";


	## loop through worlds in WORLDSTORAGE/
	for name in $WORLDSTORAGE/*; do
		log_debug "name=$name";


		## worlds are dirs, soignore files
		if [ ! -d "$name" ]; then
			continue;
		fi;


		# $name is an absolute path, so shorten
		basename="$(basename "$name")";
		log_debug "name=$name";


		# cache the name
		WORLDNAME+=("$basename");


		# cache the ramdisk-state
		is_ram=false;
		if [ -e "$WORLDSTORAGE/$basename/ramdisk" ]; then
			is_ram=true;
		fi;
		WORLDRAM+=($is_ram);
	done;


	## reset IFS
	IFS="$saveifs";


	return 0;
}


function mc_whole_backup() {
	check_backup_settings || return 1;

	echo_out "backing up entire setup into $WHOLEBACKUP";

	path="$(datepath "$WHOLEBACKUP/mine_")";
	locationOfScript="$(dirname "$(readlink -e "$0")")";
	as_user "mkdir -p $path"

	if [ -r "$locationOfScript/exclude.list" ]; then
		echo_out "...except the following files and/or dirs:";
		cat "$locationOfScript/exclude.list";
		exclude="$EXCLUDEARG$locationOfScript/exclude.list"
	fi;
	if [ "$COMPRESS_WHOLEBACKUP" ]; then
		as_user "$COMPRESSCMD $path/whole-backup$ARCHIVEENDING $MCPATH $exclude"
	else
		as_user "$STORECMD $path/whole-backup$STOREDENDING $MCPATH $exclude"
	fi;
}


function mc_world_backup() {
	#
	# Backup the worlds and puts them in a folder for each day (unless $BACKUPSCRIPTCOMPATIBLE is set)
	#

	check_backup_settings || return 1;
	get_worlds || return 1;
	today="$(date +%F-%H-%M-%S)";
	as_user "mkdir -p $BACKUPPATH"

	# Check if the backup script compatibility is enabled
	if [ "$BACKUPSCRIPTCOMPATIBLE" ]; then
		# If it is enabled, then delete the old backups to prevent errors
		echo_out "Detected that backup script compatibility is enabled, deleting old backups that are not necessary";
		as_user "rm -r $BACKUPPATH/*"
	fi

	for INDEX in "${!WORLDNAME[@]}"; do
		echo_out "Backing up minecraft ${WORLDNAME[$INDEX]}";

		# If this is set tars will be created compatible to WorldEdit
		if [ "$WORLDEDITCOMPATIBLE" ]; then
			as_user "mkdir -p $BACKUPPATH/${WORLDNAME[$INDEX]}"
			path="$(datepath "$BACKUPPATH/${WORLDNAME[$INDEX]}/" "$ARCHIVEENDING" "$ARCHIVEENDING")";
		# If is set tars will be put in $BACKUPPATH without any timestamp to be compatible with
		# [backup rotation script](https://github.com/adamfeuer/rotate-backups)
		elif [ "$BACKUPSCRIPTCOMPATIBLE" ]; then
			path="$BACKUPPATH/${WORLDNAME[$INDEX]}$ARCHIVEENDING";
		else
			as_user "mkdir -p $BACKUPPATH/$today"
			path="$(datepath "$BACKUPPATH/$today/${WORLDNAME[$INDEX]}_" "$ARCHIVEENDING" "$ARCHIVEENDING")";
		fi
		# Don't store the complete path
		if [ "$WORLDEDITCOMPATIBLE" ]; then
			as_user "cd $MCPATH && $COMPRESSCMD $path ${WORLDNAME[$INDEX]}"
		else
			as_user "$COMPRESSCMD $path $MCPATH/${WORLDNAME[$INDEX]}"
		fi
	done
}


function check_links() {
	get_worlds || return 1;

	for INDEX in "${!WORLDNAME[@]}"; do
		if ! [[ -L "$MCPATH/${WORLDNAME[$INDEX]}" || ! -a "$MCPATH/${WORLDNAME[$INDEX]}" ]]; then
			echo_err "Could not process the world named '${WORLDNAME[$INDEX]}'. Please move all worlds to ${WORLDSTORAGE}; quitting";
			return 1;
		fi;

		local link="$(ls -l "$MCPATH/${WORLDNAME[$INDEX]}" | awk '{print $11}')";
		if ${WORLDRAM[$INDEX]}; then
			if [ "$link" != "$RAMDISK/${WORLDNAME[$INDEX]}" ]; then
				as_user "rm -f $MCPATH/${WORLDNAME[$INDEX]}"
				as_user "ln -s $RAMDISK/${WORLDNAME[$INDEX]} $MCPATH/${WORLDNAME[$INDEX]}"
				echo_out "Created link for ${WORLDNAME[$INDEX]}"
			fi
		else
			if [ "$link" != "${WORLDSTORAGE}/${WORLDNAME[$INDEX]}" ]; then
				as_user "rm -f $MCPATH/${WORLDNAME[$INDEX]}"
				as_user "ln -s ${WORLDSTORAGE}/${WORLDNAME[$INDEX]} $MCPATH/${WORLDNAME[$INDEX]}"
				echo_out "Created link for ${WORLDNAME[$INDEX]}"
			fi
		fi
	done

	return 0;
}


function to_ram() {
	get_worlds || return 1;
	for INDEX in "${!WORLDNAME[@]}"; do
		if ! ( ${WORLDRAM[$INDEX]} && [ -L "$MCPATH/${WORLDNAME[$INDEX]}" ] ); then
			continue;
		fi

		as_user "mkdir -p $RAMDISK";
		as_user "rsync -rt --exclude 'ramdisk' ${WORLDSTORAGE}/${WORLDNAME[$INDEX]}/ $RAMDISK/${WORLDNAME[$INDEX]}";
		echo_out "${WORLDNAME[$INDEX]} copied to ram";
	done

	return 0;
}


function to_disk() {
	get_worlds || return 1;
	for INDEX in "${!WORLDNAME[@]}"; do
		if ${WORLDRAM[$INDEX]}; then
			as_user "rsync -rt --exclude 'ramdisk' $MCPATH/${WORLDNAME[$INDEX]}/ ${WORLDSTORAGE}/${WORLDNAME[$INDEX]}"
			echo_out "${WORLDNAME[$INDEX]} copied to disk"
		fi
	done
}



########
# Scrape the official download page, looking for $MC_JAR. If found, check version.
#
# Globals
#	MC_DOWNLOAD_PAGE	Page to scrape
#	MC_JAR				File to find
#	MC_PATH				Where to put the download
#
# Arguments
#	None
#
# Returns
#	0					Checked okay; update found OR error
#	1					Checked okay; no update
########
function check_update_vanilla() {
	MC_SERVER_URL="$(wget -q -O - "$MC_DOWNLOAD_PAGE" | grep --perl-regexp --only-matching --regexp='(?<=href=")http[^"]*minecraft_server[^"]*\.jar(?=")')";

	echo_out "Checking for update for minecraft_server.jar (Vanilla)"
	as_user "cd $MCPATH && wget -q -O $MCPATH/minecraft_server.jar.update $MC_SERVER_URL"

	if [ -r "$MCPATH/minecraft_server.jar.update" ]; then
		if ( diff "$MCPATH/$MC_JAR" "$MCPATH/minecraft_server.jar.update" >/dev/null ); then
			echo_out "You are already running the latest version of minecraft_server.jar";
			return 1;
		fi
		echo_out "Update of $MC_JAR is needed."
		return 0
	else
		echo_err "Something went wrong. Couldn't download minecraft_server.jar"
	fi
}



########
# Output the URL of the latest CraftBukkit JAR
#
# Globals
#	CB_DOWNLOAD_URL		URL of remote craftbukkit.jar. Optionally: with $CB_RELEASE replaced with 'RELEASE'
#	CB_RELEASE			Branch to download, e.g. unstable, beta, stable
#
# Arguments
#	None
#
# Returns
#	0					On success
#	1					On failure
#	stdout				URL of file
########
function get_cb_release_channel() {
	local url="$CB_DOWNLOAD_URL";


	case "$CB_RELEASE" in
		unstable|UNSTABLE|Unstable|dev|development)
			url=${url/RELEASE/dev};
			;;


		beta|Beta|BETA)
			url=${url/RELEASE/beta};
			;;


		*)
			url=${url/RELEASE/rb};
			;;


	esac;


	echo_quiet "$url";

	return 0;
}



########
# Compare the (local) update file to $CB_JAR and report the result
#
# Globals
#	CB_JAR			Name of the Craft Bukkit jar-file
#	CB_RELEASE		Which channel to follow (e.g. Alpha)
#	MCPATH			Where to find $CB_JAR and the update on this server
#
# Arguments
#	None
#
# Returns
#	0				Ran okay *and* update available
#	1				Error *or* no update available
########
function check_update_craftbukkit() {
	echo_info "Checking for update for craftbukkit.jar"
	echo_info "You are on release channel \"$CB_RELEASE\""


	# fetch the JAR from get_cb_release_channel()
	as_user "cd $MCPATH && wget -q -O $MCPATH/craftbukkit.jar.update $(get_cb_release_channel)";


	# if no downloaded file, quit
	if [ ! -r "$MCPATH/craftbukkit.jar.update" ]; then
		echo_err "Something went wrong. Couldn't download craftbukkit.jar; quitting";
		return 1;
	fi;


	# if no change, quit
	if ( diff "$MCPATH/$CB_JAR" "$MCPATH/craftbukkit.jar.update" >/dev/null ); then
		echo_out "You are already running the latest version of craftbukkit.jar";
		return 1;
	fi;


	# output
	echo_out "Update of $CB_JAR is needed";


	return 0
}


function mc_update() {
	if is_running
	then
		echo_err "$SERVICE is running! Will not start update";
	else
		if check_update_vanilla
		then
			if [ -r "$MCPATH/minecraft_server.jar.update" ]
			then
				as_user "mv $MCPATH/minecraft_server.jar.update $MCPATH/$MC_JAR"
				echo_out "Thats it. Update of $MC_JAR done";
			else
				echo_err "Something went wrong. Couldn't replace your original $MC_JAR with minecraft_server.jar.update"
			fi
		else
			echo_out "Not updating $MB_JAR. It's not necessary"
			as_user "rm $MCPATH/minecraft_server.jar.update"
		fi

		if check_update_craftbukkit
		then
			if [ -r "$MCPATH/craftbukkit.jar.update" ]
			then
				as_user "mv $MCPATH/craftbukkit.jar.update $MCPATH/$CB_JAR"
				echo_out "Thats it. Update of $CB_JAR done";
			else
				echo_err "Something went wrong. Couldn't replace your original $CB_JAR with craftbukkit.jar.update"
			fi
		else
			echo_out "Not updating $CB_JAR. It's not necessary"
			as_user "rm $MCPATH/craftbukkit.jar.update"
		fi
	fi
}


function change_ramdisk_state() {
	if [ ! -e "$WORLDSTORAGE/$1" ]; then
		echo_err "World \"$1\" not found; quitting";
		return 1;
	fi

	if [ -e "$WORLDSTORAGE/$1/ramdisk" ]; then
		rm "$WORLDSTORAGE/$1/ramdisk";
		echo_out "Removed ramdisk flag from \"$1\"";
	else
		touch "$WORLDSTORAGE/$1/ramdisk";
		echo_out "Added ramdisk flag to \"$1\"";
	fi

	echo_out "Changes will only take effect after server is restarted";

	return 0;
}


function overviewer_start() {
	if [ ! -e "$OVPATH/overviewer.py" ]; then
		if [ ! "$OVPATH" = "apt" ]; then
			echo_err "Minecraft-Overviewer is not installed in \"$OVPATH\"; quitting"
			return 1;
		fi

		echo_out "Using APT repository installed Minecraft-Overviewer"
	fi


	# if no sink-dir, make it - else quit
	if [ ! -e "$OUTPUTMAP" ]; then
		as_user "mkdir -p $OUTPUTMAP";
	fi
	if [ ! -e "$OUTPUTMAP" ]; then
		echo_err "Can't find \$OUTPUTMAP ($OUTPUTMAP); quitting";
		return 1;
	fi


	if [ -e "$OVCONFIGPATH/$OVCONFIGNAME" ]; then
		echo_out "Start generating map with Minecraft-Overviewer...";
		if [ "$OVPATH" = "apt" ]; then
			as_user "overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME";
		else
			as_user "python $OVPATH/overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME";
		fi
		echo_out "Map generated."
	else
		echo_out "No config file found. Start with default config...";
		if [ -z "$1" ] || [ ! -e "$OVBACKUP/$1" ]; then
			echo_out "World \"$1\" not found."
		else
			echo_out "Start generating map with Minecraft-Overviewer...";
			if [ "apt" = "$OVPATH" ]; then
				as_user "nice overviewer.py $OVBACKUP/$1 $OUTPUTMAP";
			else
				as_user "nice python $OVPATH/overviewer.py $OVBACKUP/$1 $OUTPUTMAP";
			fi;
			echo_out "Map generated."
		fi;
	fi;

	return 0;
}


function overviewer_copy_worlds() {
	#
	# Backup the worlds for overviewer
	#

	get_worlds || return 1;
	for INDEX in "${!WORLDNAME[@]}"; do
		echo_out "Copying minecraft ${WORLDNAME[$INDEX]}";
		as_user "mkdir -p $OVBACKUP"
		as_user "rsync -rt --delete $WORLDSTORAGE/${WORLDNAME[$INDEX]} $OVBACKUP/${WORLDNAME[$INDEX]}"
	done
}



########
# Queries the Server for the list of users, then outputs to stdout
#
# Globals
#	SERVERLOG		The file that holds the Server's output
#
# Arguments
#	None
#
# Returns
#	0				On success
#	1				On failure
#	stdout			Formated list of users currently connected to the server
########
function echo_connected_players() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	# query server & wait for response
	mc_command list || return 1;
	sleep 1s;


	local players;


	# get the list from log
	players="$(tac "$SERVERLOG" | grep --before-context 1 --max-count 1 'players online' | head -n 1)";
	echo_debug "players=$players";

	if [ -z "$players" ]; then
		echo_err "Can't find connected players in \$SERVER_LOG; quitting";
		return 1;
	fi;


	# remove the log-fluff
	players="${players:33}";


	# handle zero-players
	if [ -z "$players" ]; then
		players='No players connected';
	fi;
	echo_debug "players=$players";


	# change line to list
	players="${players//, /\\n\\t}";


	# print & return
	echo_info	"These players are connected:"
	echo_quiet	"\t$players";
	return 0;
}



########
# Wraps echo_connected_players() to return a count
#
# Globals
#	None
#
# Arguments
#	None
#
# Returns
#	0			On success
#	1			On failure
#	stdout		Integer count of players online
########
function echo_playercount() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	local cache=$VERBOSITY;	# cache the current VERBOSITY
	VERBOSITY=$VERBOSITY_QUIET;	# set to known level (quiet)
	local player_list="$(echo_connected_players)";
	VERBOSITY=$cache;	# reset VERBOSITY
	echo_debug "player_list=$player_list";


	# if no users; skip
	if [ 'No users connected' = "$player_list" ]; then
		echo_quiet 0;
		return 0;
	fi;


	# count the words (usernames); output
	echo_info	"There are this many players online:";
	echo_quiet	"$(echo "$player_list" | wc -w)";


	return 0;
}



########
# Checks server-log for recent player activity
#
# Globals
#	SERVERLOG	File containing player activity
#
# Arguments
#	None
#
# Returns
#	0			On success
#	1			On failure
#	stdout		Formatted list of recent player activity
########
function echo_recent_players() {
	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	# init vars
	local log;


	# get the log & filter for player activity
	echo_debug "SERVERLOG=$SERVERLOG";
	if [ ! -f "$SERVERLOG" ]; then
		echo_err "Can't find \$SERVERLOG ($SERVERLOG); quitting";
		return 1;
	fi;
	log="$(grep 'joined the game\|left the game' "$SERVERLOG")";
	echo_debug "log=$log";


	# format for display
	log="${log// \[Server thread\/INFO\]/}";
	if [ -z "$log" ]; then
		log="No recent players";
	fi;
	echo_debug "log=$log";


	# output
	echo_info "Recently player activity:";
	echo_quiet "$log";


	return 0;
}



########
# Output the server's current whitelist, by querying the daemon
#
# Globals
#	SERVERLOG	File where the daemon will put its response
#
# Arguments
#	None
#
# Returns
#	stdout		List of players
#	0|1
########
function echo_whitelist() {
	mc_command "whitelist list" || {
		echo_err "Failed to talk to daemon; quitting";
		return 1;
	}

	# wait for reply
	sleep 1s


	local whitelist;

	# extract data from log
	whitelist="$(tac "$SERVERLOG" | grep -m 1 -B 1 'whitelisted players:' | head -n 1)";
	whitelist="${whitelist:33}";			# remove the log-fluff
	whitelist="${whitelist// and /, }";		# remove ' and '
	whitelist="${whitelist//, /\\n\\t}";	# change line to list


	# Pre MC v1.8.8
	if [ -z "$whitelist" ]; then
		whitelist="$(tac "$SERVERLOG" | grep -m 1 'White-listed players:')";
		whitelist="${whitelist:49}";	# remove the log-fluff
		whitelist="${whitelist//, /\n}";	# change line to list
	fi;


	echo_debug "whitelist=$whitelist";
	if [ -z "$whitelist" ]; then
		echo_err "Daemon failed to output the whitelist to log; quitting";
		return 1;
	fi;
	echo_debug "whitelist=$whitelist";


	echo_out	"Your whitelist is:"
	echo_quiet	"\t$whitelist";


	return 0;
}



########
# (Messily) kill the running server
#
# Globals
#	MCPATH		{ As PID-file
#	SCREEN		{
#	USERNAME
#
# Arguments
#	None
#
# Returns
#	0			On success
#	1			On failure
########
function force_exit() {
	## init vars
	local pid pidfile;


	## find pidfile
	pidfile="${MCPATH}/${SCREEN}.pid";
	log_debug "pidfile $pidfile";
	if [ ! -f "$pidfile" ]; then
		echo_err "Can't find pidfile ($pidfile); quitting";
		return 1;
	fi;


	## find pid
	pid="$(head -1 "$pidfile")";
	log_debug "pid $pid";
	if [ -n "$pid" ]; then
		echo_err "Can't find PID in pidfile ($pidfile); quitting";
		return 1;
	fi;


	echo_out "KILLING SERVER PROCESSES!!!";


	## Display which processes will be killed
	echo_info "Killing PID: $pid";
	ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {};
	ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {};
	ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {};


	## Kill the processes
	kill "$pid";
	ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i kill {};
	ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i kill {};
	ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i kill {};


	## tidy the file
	rm "$pidfile";


	return 0;
}


function get_script_location() {
	echo_quiet "$(dirname "$(readlink -e "$0")")";
	return 0;
}


function check_permissions() {
	as_user "touch $pidfile"
	if ! as_user "test -w '$pidfile'" ; then
		echo_err "Check Permissions. Cannot write to $pidfile. Correct the permissions and then excute: $0 status"
	fi
}



########
# Parks and stops the server
########
function server_stop() {
	if ! is_running; then
		return 0;
	fi;

	mc_say "SERVER SHUTTING DOWN IN 10 SECS!";
	sleep 10;

	mc_stop;
	to_disk;

	if is_running; then
		echo_err "Failed to stop server";
		return 1;
	fi;

	return 0;
}



########
# Decide with function(s) to call, based on commandline call
#
# Globals
#	INIT_COMMAND		(Main) command to run
#	INIT_SUBCOMMAND		Variant of <command> to run
#
# Arguments
#	@					All parameters, to pass to e.g. redirect functions
#
# Returns
#	0					On success
#	1					On failure
########
function route_command() {
	echo_debug "@=$*";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";


	local i was_running;
	was_running=false;
	case "$INIT_COMMAND" in
		start)
			# Starts the server
			if is_running; then
				echo_out "Server already running";
				return 0;
			fi;

			check_links || return 1;
			to_ram

			mc_start || {
				echo_err "Failed to start; quitting";
				return 1;
			}
			;;


		stop)
			server_stop || {
				echo_err "Failed to stop; quitting";
				return 1;
			}
			echo_out 'Server stopped';
			;;


		restart)
			if is_running; then
				mc_say "SERVER REBOOTING!";
				server_stop || return 1;
				echo_out 'Server stopped';
			fi;

			check_links || return 1;
			to_ram;

			mc_start || {
				echo_err "Failed to restart; quitting";
				return 1;
			}
			echo_out 'Server started';
			;;


		reload)
			# Reloads server configuration
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi

			mc_say "Reloading server configuration";
			mc_reload || {
				echo_err "Failed to reload config";
				return 1;
			}
			;;


		whitelist)
			if ! is_running; then
				echo_out "Server not running; skipping";
				return 0;
			fi

			whitelist || return 1;
			;;


		whitelist-reload)
			# Reloads the whitelist
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi

			mc_command "whitelist reload" || {
				echo_err "Failed to reload whitelist; quitting";
				return 1;
			}
			;;


		whitelist-add)
			# Adds a player to the whitelist
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi;

			mc_command "whitelist add $INIT_SUBCOMMAND" || {
				echo_err "Failed to add; quitting";
				return 1;
			}
			;;


		backup)
			# Backups world
			if is_running; then
				was_running=true;
				mc_say "Backing up world";
				mc_saveoff
				to_disk
			fi;

			mc_world_backup

			if $was_running; then
				mc_saveon
				mc_say "Backup complete";
			fi
			;;


		whole-backup)
			# Backup everything
			if is_running; then
				was_running=true;
				mc_say "COMPLETE SERVER BACKUP IN 10 SECONDS";
				mc_say "WARNING: WILL RESTART SERVER SOFTWARE!"
				mc_stop
				to_disk
			fi;

			mc_whole_backup || return 1;

			if $was_running; then
				check_links || return 1;
				mc_start
			fi
			;;


		check-update)
			check_update_vanilla
			check_update_craftbukkit
			as_user "rm $MCPATH/minecraft_server.jar.update"
			as_user "rm $MCPATH/craftbukkit.jar.update"
			;;


		check-update)
			echo_err "'$SELF check-update' is deprecated; please call '$SELF check update' instead";
			return 1;
			;;


		update)
			#update minecraft_server.jar and craftbukkit.jar (thanks karrth)
			if is_running; then
				was_running=true;
				mc_say "SERVER UPDATE IN 10 SECONDS";
			fi

			if ! server_stop ; then
				echo_err "Can't update a running server; quitting...";
				return 1;
			fi

			mc_whole_backup
			mc_update

			if $was_running; then
				check_links || return 1;
				mc_start
			fi
			;;


		to-disk)
			# Writes from the ramdisk to disk, in case the server crashes.
			mc_saveoff
			to_disk
			mc_saveon
			;;


		save-off)
			# Flushes the state of the world to disk, and then disables
			# saving until save-on is called (useful if you have your own
			# backup scripts).
			if is_running; then
				mc_saveoff
			else
				echo_out "Server was not running, syncing from ram anyway...";
			fi
			to_disk
			;;


		save-on)
			# Re-enables saving if it was disabled by save-off.
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi

			mc_saveon || return 1;
			;;


		say)
			# Says something to the ingame chat
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi

			mc_say "$INIT_SUBCOMMAND" || return 1;
			;;


		command)
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi;

			mc_command "$INIT_SUBCOMMAND" || return 1;
			echo_out "Sent command: \"$INIT_SUBCOMMAND\"";
			;;


		connected)
			echo_connected_players || return 1;
			;;


		playercount)
			echo_playercount || return 1;
			;;


		log-roll)
			log_roll || return 1;
			;;


		log)
			# Display server log using 'cat'.
			cat "$SERVERLOG";
			;;


		last)
			echo_recent_players || return 1;
			;;


		status)
			# Shows server status
			if is_running; then
				echo_quiet "$SERVICE is running";
			else
				echo_quiet "$SERVICE is not running";
			fi
			;;


		watchdog)
			# Ensures server is still running
			if is_running; then
				echo_out "Server is running";
				return 0;
			fi

			echo_out "Server is stopped; re-starting...";
			server_stop && mc_start;

			if ! is_running; then
				echo_err "Failed to restart server; quitting";
				return 1;
			fi

			echo_out "Server is running";
			;;


		version)
			if ! is_running; then
				echo_out "No running server; skipping";
				return 0;
			fi;

			mc_command 'version' || return 1;
			tac "$SERVERLOG" | grep -m 1 "This server is running"
			;;


		links)
			check_links || return 1;
			;;


		ramdisk)
			change_ramdisk_state "$INIT_SUBCOMMAND";
			;;


		worlds)
			get_worlds || return 1;
			echo_info "Found ${#WORLDNAME[@]} world(s) in $WORLDSTORAGE:";
			for i in "${!WORLDNAME[@]}"; do
				if ${WORLDRAM[$i]}; then
					echo_quiet "${WORLDNAME[$i]} (ramdisk)"
				else
					echo_quiet "${WORLDNAME[$i]}";
				fi
			done
			;;


		overviewer)
			if is_running; then
				was_running=true;
				mc_say "Generating overviewer map";
				mc_saveoff
				to_disk
			fi

			overviewer_copy_worlds;

			if $was_running; then
				mc_saveon;
			fi

			overviewer_start "$INIT_SUBCOMMAND";
			;;


		screen)
			if ! is_running; then
				echo_out "Server is not running. Do you want to start it?";
				echo_quiet "Please put \"Yes\", or \"No\": ";
				read START_SERVER
				case "$START_SERVER" in
					[Yy]|[Yy][Ee][Ss])
						check_links || return 1;
						to_ram
						mc_start
						as_user "script /dev/null -q -c \"screen -rx $SCREEN\""
						;;


					[Nn]|[Nn][Oo])
						clear
						echo_err "Aborting startup!"
						sleep 1
						clear
						return 1;
						;;


					*)
						clear
						echo_err "Invalid input"
						sleep 1
						clear
						return 1;
						;;
				esac
			fi

			as_user "script /dev/null -q -c \"screen -rx $SCREEN\"" || return 1;
			;;


		kill)
			# Get terminal's character width
			WIDTH="$(stty size | cut -d ' ' -f 2)";

			# Chop output after WIDTH chars
			pstree | grep MDSImporte | cut -c "1-${WIDTH}";

			echo_quiet "Killing the server is an EMERGENCY procedure, and should not be used to perform a normal shutdown! All changes younger than 15 minutes could be permanantly lost and WORLD CORRUPTION is possible! Are you ABSOLUTELY POSITIVE this is what you want to do?";
			echo_quiet "Please put \"Yes\", or \"No\": ";

			# Determine which option was specified
			read user_input; case "$user_input" in
				# If yes, kill the server
				[Yy]|[Yy][Ee][Ss])
					if ! force_exit ; then
						echo_err "Failed to kill processes; quitting";
						return 1;
					fi;
					if is_running ; then
						echo_err "Killing completed okay, but server is still running; quitting";
						return 1;
					fi;
					return 0;
					;;


				# If no, quit
				[Nn]|[Nn][Oo])
					echo_info "Cancelling forced-exit";
					return 0;
					;;


				# If anything else, quit
				*)
					echo_err "Invalid Input; quitting";
					return 1;
					;;


			esac;
			;;


		help|--help|-h)
			echo_usage;
			;;


		mci-version|mci_version|script-version|script_version)
			echo_mci_version;
			;;


		*)
			echo_err "No such command as '$SELF $INIT_COMMAND'; quitting";
			echo_out;
			echo_usage;
			return 1;
			;;


	esac;


	return 0;
}



########
# Reads commandline parameters, loads the config, and runs the command
#
# Globals
#	None
#
# Arguments
#	@			Passed to sub-functions
#
# Returns
#	0			On success
#	1			On failure
########
function main() {
	## read commandline options
	handle_commandline_options "$@" || return 1;

	## load defaults & user config
	config_load || return 1;

	## run the command
	route_command "$@" || return 1;	# need to inject $@ so route_command() can pass it on

	return 0;
}



###############################################################################
## Run, tidy, quit
###############################################################################

trap force_exit SIGINT;
main "$@" || exit 1;
exit 0;
