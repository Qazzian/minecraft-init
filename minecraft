#!/bin/bash
# /etc/init.d/minecraft

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Init script for minecraft/bukkit server, with rolling logs and use of ramdisk for less lag.
### END INIT INFO

# Created by Ahtenus

# Based on http://www.minecraftwiki.net/wiki/Server_startup_script
# Support for multiworld by Benni-chan
# Log rolls without needing restarts by Solorvox
# Option for killing server in an emergency by jbondhus



###############################################################################
## Define constants
###############################################################################


## Quiet		:= no output
readonly export VERBOSITY_QUIET=-1;


## Default		:= success messages; etc
readonly export VERBOSITY_DEFAULT=0;


## Info			:= values of subshells; function-calls, in prose
readonly export VERBOSITY_INFO=1;


## Verbose		:= final value of vars, in prose
readonly export VERBOSITY_VERBOSE=2;


## Debugging	:= all possible outputs, tersely
readonly export VERBOSITY_DEBUG=3;



###############################################################################
## Init vars
###############################################################################


## Level of debugging-info to output
VERBOSITY=$VERBOSITY_DEFAULT;



###############################################################################
## Functions
###############################################################################



########
# Output the current version of MineCraft-Init
########
function echo_mci_version() {
	echo_quiet '2.6.4';
	return 0;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#   VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Verbosity-level, e.g. VERBOSITY_QUIET
#	2	Message
#
# Returns
#	0|1
########
function echo_by_level {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Verbosity-level is not an integer; quitting";
		return 1;
	fi;


	# if this message is verbose, but we're quieter, stop here
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	local message="$2";


	# if debugging, prefix with function
	if [ "$1" -ge "$VERBOSITY_DEBUG" ]; then
		message="[${FUNCNAME[2]}] $message";
	fi;


	# put to stdout
	echo -e "$message";


	return 0;
}


## wrappers for echo_by_level
function echo_quiet()	{ echo_by_level "$VERBOSITY_QUIET"		"${1-}";	return $?; }
function echo_out()		{ echo_by_level "$VERBOSITY_DEFAULT"	"${1-}";	return $?; }
function echo_info()	{ echo_by_level "$VERBOSITY_INFO"		"${1-}";	return $?; }
function echo_verbose()	{ echo_by_level "$VERBOSITY_VERBOSE"	"${1-}";	return $?; }
function echo_debug()	{
	local status=0;

	echo_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;
	log_by_level "$VERBOSITY_DEBUG" "${1-}" || status=1;

	return $status;
}



########
# Send errors to stderr
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo()
########
function echo_err() {
	echo -e "$@" 1>&2;
	return $?;
}



########
# Send errors to stderr
#
# DEPRECATED by echo_err()
#
# Globals
#	None
#
# Arguments
#	@			Message to output
#
# Returns
#	?			As per echo_err()
########
function echoerr() {
	echo_err "echoerr() is deprecated; use echo_err() instead";
	echo_err "$@";
	return $?;
}



########
# Output the given message as appropriate, if appropriate
#
# Globals
#   VERBOSITY	Which level(s) of output to process, and which to discard
#
# Arguments
#	1	Log-level := VERBOSITY_QUIET <-> VERBOSITY_DEBUG
#	2	Message
#
# Returns
#	0|1
########
function log_by_level() {
	if [ 2 -ne $# ]; then
		echo_err "Usage: ${FUNCNAME[0]} <level> <message>";
		return 1;
	fi;


	if [[ ! $1 =~ ^-?[0-9]+$ ]]; then
		echo_err "Log-level is not an integer; quitting";
		return 1;
	fi;


	# if we're too quiet to show the message, finish
	if [ "$1" -gt "$VERBOSITY" ]; then return 0; fi


	# if can't write to file, crash
	if [ ! -f "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't find latest.log in $MCPATH/logs/; crashing";
		exit 1;
	fi;
	if [ ! -w "$MCPATH/logs/latest.log" ]; then
		echo_err "Can't write to $MCPATH/logs/latest.log; crashing";
		exit 1;
	fi;


	# log to file -- with date, level, function
	local function_name="${FUNCNAME[1]}";	# get calling function
	function_name="${function_name#log_}";	# if log_foo, remove prefix
	function_name="${function_name#echo_}";	# if echo_foo, remove prefix
	echo "[$(date +%Y-%m-%d:%H:%M:%S)] [$function_name] [${FUNCNAME[2]}] $2" >> "$MCPATH/logs/latest.log";


	return 0;
}


## wrappers for log_by_level
function log_quiet()	{ log_by_level "$VERBOSITY_QUIET" "$1";		return $?; }
function log()			{ log_by_level "$VERBOSITY_DEFAULT" "$1";	return $?; }
function log_info()		{ log_by_level "$VERBOSITY_INFO" "$1";		return $?; }
function log_verbose()	{ log_by_level "$VERBOSITY_VERBOSE" "$1";	return $?; }
function log_debug()	{ log_by_level "$VERBOSITY_DEBUG" "$1"; 	return $?; }



########
# Extract commandline parameters from call
#
# Globals
#   INIT_COMMAND		The command to run
#   INIT_SUBCOMMAND	The sub-command to run and/or message to pass, etc
#   VERBOSITY		Incremented by -v; reset by -q
#
# Arguments
#   @					All commandline parameters
#
# Returns
#   0|1
########
function handle_commandline_options {
	echo_debug "@=$*";


	OPTIND=1;		# Reset in case getopts has been used previously in the shell.
	while getopts 'qv' option; do
		echo_debug "option=$option";
		case $option in
			q)	VERBOSITY=$VERBOSITY_QUIET;
				;;


			v)	VERBOSITY=$((VERBOSITY+1));
				;;


			*)	echo_err "Unrecognised parameter '$option'; quitting";
				return 1;
				;;


		esac
	done
	echo_debug "VERBOSITY=$VERBOSITY";


	shift $((OPTIND-1));	# skip the params we've already processed


	export readonly INIT_COMMAND="${1-}";
	export readonly INIT_SUBCOMMAND="${2-}";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";



	return 0;
}



## output supported commands
function echo_usage {
	echo_quiet "Usage: $(basename "$0") [<options>] <command>";
	echo_out;
	echo_out "Where <options> is zero or more of:";
	echo_out "   -q            Quiet. Decreases the script's verbosity";
	echo_out "   -v            Verbose. Increases the script's verbosity. May be repeated. Max is three";
	echo_out;
	echo_out "Where <command> is one of:";
	echo_out "   start \t\t Starts the server";
	echo_out "   stop \t\t Stops the server";
	echo_out "   kill \t\t Kills the server";
	echo_out "   restart \t\t Restarts the server";
	echo_out "   watchdog \t Ensures server is still running";
	echo_out "   reload \t\t Reloads the server configuration";
	echo_out "   backup \t\t Backups the worlds defined in the script";
	echo_out "   whole-backup \t Backups the entire server folder";
	echo_out "   check-update \t Checks for updates of $CB_JAR and $MC_JAR";
	echo_out "   update \t\t Fetches the latest version of minecraft.jar server and Bukkit";
	echo_out "   log-roll \t\t Moves and compresses the logfiles";
	echo_out "   log \t\t\t Prints the server log";
	echo_out "   to-disk \t\t Copies the worlds from the ramdisk to worldstorage";
	echo_out "   save-off \t\t Flushes the world to disk and then disables saving";
	echo_out "   save-on \t\t Re-enables saving if it was previously disabled by save-off";
	echo_out "   say \t\t\t Prints the given string to the ingame chat";
	echo_out "   connected \t\t Lists connected users";
	echo_out "   playercount \t\t Prints the number of connected users";
	echo_out "   status \t\t Displays server status";
	echo_out "   version \t\t Displays Bukkit version and then exits";
	echo_out "   links \t\t Creates nessesary symlinks";
	echo_out "   last \t\t Displays recently connected users";
	echo_out "   worlds \t\t Displays a list of available worlds";
	echo_out "   ramdisk WORLD \t Toggles ramdisk configuration for WORLD";
	echo_out "   overviewer WORLD \t Creates a map of the WORLD with Minecraft-Overviewer";
	echo_out "   whitelist \t\t Prints the current whitelist";
	echo_out "   whitelist-add NAME \t Adds the specified player to the server whitelist";
	echo_out "   whitelist-reload \t Reloads the whitelist";
	echo_out "   screen \t\t Shows the server screen";
	echo_out "   script-version        Show this script's version";
	echo_out "   help \t\t Shows this text";

	return 0;
}



########
# Runs an arbitrary command as USERNAME
#
# Globals
#	USERNAME
#
# Arguments
#	1		Command to run
#
# Returns
#	0|1
########
as_user() {
	echo_debug "1=$1";


	if [ 1 -ne $# ] || [ -z "$1" ]; then
		echo_err "Command is missing or invalid; quitting";
		return 1;
	fi;


	local me="$(whoami)";
	echo_debug "me=$me";
	echo_debug "USERNAME=$USERNAME";


	# if we're already USERNAME, run
	if [ "$me" = "$USERNAME" ] ; then
		bash -c "$1" || return 1;
		return 0;
	fi;


	su "$USERNAME" -s /bin/bash -c "$1" || return 1;


	return 0;
}


is_running() {
	# Checks for the minecraft servers screen session
	# returns true if it exists.
	pidfile=${MCPATH}/${SCREEN}.pid

	if [ -f "$pidfile" ]
	then
		pid=$(head -1 $pidfile)
		if ps ax | grep -v grep | grep ${pid} | grep "${SCREEN}" > /dev/null
		then
			return 0
		else
			if [ -z "$isInStop" ]
			then
				if [ -z "$roguePrinted" ]
				then
					roguePrinted=1
					echo_err "Rogue pidfile found!"
				fi
			fi
			return 1
		fi
	else
		if ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" > /dev/null
		then
			echo_err "No pidfile found, but server's running."
			echo_err "Re-creating the pidfile."

			pid=$(ps ax | grep -v grep | grep "${SCREEN} ${INVOCATION}" | cut -f1 -d' ')
			check_permissions
			as_user "echo $pid > $pidfile"

			return 0
		else
			return 1
		fi
	fi
}


datepath() {
	# datepath path filending-to-check returned-filending

	# Returns an file path with added date between the filename and file ending.
	# $1 filepath (not including file ending)
	# $2 file ending to check for uniqueness
	# $3 file ending to return

	if [ -e $1`date +%F`$2 ]
	then
		echo_quiet $1`date +%FT%T`$3
	else
		echo_quiet $1`date +%F`$3
	fi
}


mc_start() {
	servicejar=$MCPATH/$SERVICE
	if [ ! -f "$servicejar" ]
	then
		echo_err "Failed to start: Can't find the specified Minecraft jar under $servicejar. Please check your config!"
		exit 1
	fi

	pidfile=${MCPATH}/${SCREEN}.pid
	check_permissions

	as_user "cd $MCPATH && screen -dmS $SCREEN $INVOCATION"
	as_user "screen -list | grep "\.$SCREEN" | cut -f1 -d'.' | head -n 1 | tr -d -c 0-9 > $pidfile"

	#
	# Waiting for the server to start
	#
	seconds=0
	until is_running
	do
		sleep 1
		seconds=$seconds+1
		if [[ $seconds -eq 5 ]]
		then
			echo_info "Still not running, waiting a while longer..."
		fi
		if [[ $seconds -ge 120 ]]
		then
			echo_err "Failed to start, aborting."
			exit 1
		fi
	done
	echo_out "$SERVICE is running."
}



########
# Passes a string to the Server Jar, as a command
#
# Globals
#	SCREEN		Name of Screen session to command
#
# Arguments
#	1			String to say
#
# Returns
#	0|1
########
mc_command() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	if [ 1 -ne $# ]; then
		echo_err "Can't find command; quitting";
		return 1;
	fi;
	if [ -z "$1" ]; then
		echo_err "Command ($1) is empty; quitting";
		return 1;
	fi;


	as_user "screen -p 0 -S $SCREEN -X stuff \"$1\"\\\015" || return 1;


	return 0;
}


mc_saveoff() {
	if is_running
	then
		echo_out "$SERVICE is running... suspending saves"
		mc_command save-off
		mc_command save-all
		sync
		sleep 10
	else
		echo_info "$SERVICE was not running. Not suspending saves."
	fi
}


mc_saveon() {
	if is_running
	then
		echo_out "$SERVICE is running... re-enabling saves"
		mc_command save-on
	else
		echo_out "$SERVICE was not running. Not resuming saves."
	fi
}



########
# Broadcasts a message in-game
#
# Globals
#	None
#
# Arguments
#	1		String to say
#
# Returns
#	0|1
########
mc_say() {
	echo_debug "1=$1";


	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	if [ -z "$1" ]; then
		echo_err "Message ($1) is empty; quitting";
		return 1;
	fi;


	mc_command "say $1" || return 1;
	echo_out "Said: $1";


	return 0;
}


mc_stop() {
	pidfile=${MCPATH}/${SCREEN}.pid
	#
	# Stops the server
	#
	echo_info "Saving worlds..."
	mc_command save-all
	sleep 10
	echo_out "Stopping server..."
	mc_command stop
	sleep 0.5
	#
	# Waiting for the server to shut down
	#
	seconds=0
	isInStop=1
	while is_running
	do
		sleep 1
		seconds=$seconds+1
		if [[ $seconds -eq 5 ]]
		then
			echo_info "Still not shut down, waiting a while longer..."
		fi
		if [[ $seconds -ge 120 ]]
		then
			logger -t minecraft-init "Failed to shut down server, aborting."
			echo_err "Failed to shut down, aborting."
			exit 1
		fi
	done
	as_user "rm $pidfile"
	unset isInStop
	is_running
	echo_out "$SERVICE is now shut down."
}


mc_reload() {
        echo_out "$SERVICE is running... reloading."
        mc_command reload
}


check_backup_settings() {
	case "$BACKUPFORMAT" in
		tar)
			COMPRESSCMD="tar -hcjf"
			STORECMD="tar -cpf"
			ARCHIVEENDING=".tar.bz2"
			STOREDENDING=".tar"
			EXCLUDEARG="-X "
			;;


		zip)
			COMPRESSCMD="zip -rq"
			STORECMD="zip -rq -0"
			ARCHIVEENDING=".zip"
			STOREDENDING=".zip"
			EXCLUDEARG="-x@"
			;;


		*)
			echo_err "$BACKUPFORMAT is not a supported backup format"
			exit 1
			;;


	esac
}


log_roll() {
	# Moves the logfiles and compresses that backup directory
	check_backup_settings
	local readonly path="$(datepath $LOGPATH/logs_ $ARCHIVEENDING)";

	as_user "mkdir -p $path"

	shopt -s extglob
	for FILE in $(ls $MCPATH/logs/*.log)
	do
		as_user "cp $FILE $path"
		# only if previous command was successful
		if [ $? -eq 0 ]; then
			if [[ "$FILE" = @(*-+([0-9]).log) && "$FILE" = !(*-0.log) ]]
			# some mods already roll logs. remove all but the most recent file
			# which ends with -0.log
			then
				as_user "rm $FILE"
			else
			# truncate the existing log without restarting server
				as_user "cp /dev/null $FILE"
				as_user "echo \"Previous logs rolled to $path\" > $FILE"
			fi
		else
			echo_err "Failed to rotate log from $FILE into $path"
		fi
	done

	as_user "$COMPRESSCMD $path$ARCHIVEENDING $path"
	if [ $? -eq 0 ]; then
		as_user "rm -r $path"
	fi
}


get_worlds() {
	SAVEIFS=$IFS
	IFS=$(echo -en "\n\b")

	a=1
	for NAME in $(ls $WORLDSTORAGE)
	do
		if [ -d $WORLDSTORAGE/$NAME ]
		then
			WORLDNAME[$a]=$NAME
			if [ -e $WORLDSTORAGE/$NAME/ramdisk ]
			then
				WORLDRAM[$a]=true
			else
				WORLDRAM[$a]=false
			fi
			a=$a+1
		fi
	done

	IFS=$SAVEIFS
}


mc_whole_backup() {
	check_backup_settings
	echo_out "backing up entire setup into $WHOLEBACKUP"
	path=`datepath $WHOLEBACKUP/mine_`
	locationOfScript=$(dirname "$(readlink -e "$0")")
	as_user "mkdir -p $path"

	if [ -r "$locationOfScript/exclude.list" ]
	then
		echo_out "...except the following files and/or dirs:"
		cat $locationOfScript/exclude.list
		exclude="$EXCLUDEARG$locationOfScript/exclude.list"
	fi
	if [ "$COMPRESS_WHOLEBACKUP" ]
	then
		as_user "$COMPRESSCMD $path/whole-backup$ARCHIVEENDING $MCPATH $exclude"
	else
		as_user "$STORECMD $path/whole-backup$STOREDENDING $MCPATH $exclude"
	fi
}


mc_world_backup() {
	#
	# Backup the worlds and puts them in a folder for each day (unless $BACKUPSCRIPTCOMPATIBLE is set)
	#

	check_backup_settings
	get_worlds
	today="`date +%F-%H-%M-%S`"
	as_user "mkdir -p $BACKUPPATH"

	# Check if the backup script compatibility is enabled
	if [ "$BACKUPSCRIPTCOMPATIBLE" ]
	then
		# If it is enabled, then delete the old backups to prevent errors
		echo_out "Detected that backup script compatibility is enabled, deleting old backups that are not necessary."
		as_user "rm -r $BACKUPPATH/*"
	fi

	for INDEX in ${!WORLDNAME[@]}
	do
		echo_out "Backing up minecraft ${WORLDNAME[$INDEX]}"
		if [ "$WORLDEDITCOMPATIBLE" ]
		# If this is set tars will be created compatible to WorldEdit
		then
			as_user "mkdir -p $BACKUPPATH/${WORLDNAME[$INDEX]}"
			path=`datepath $BACKUPPATH/${WORLDNAME[$INDEX]}/ $ARCHIVEENDING $ARCHIVEENDING`
		elif [ "$BACKUPSCRIPTCOMPATIBLE" ]
		# If is set tars will be put in $BACKUPPATH without any timestamp to be compatible with
		# [backup rotation script](https://github.com/adamfeuer/rotate-backups)
		then
			path=$BACKUPPATH/${WORLDNAME[$INDEX]}$ARCHIVEENDING
		else
			as_user "mkdir -p $BACKUPPATH/${today}"
			path=`datepath $BACKUPPATH/${today}/${WORLDNAME[$INDEX]}_ $ARCHIVEENDING $ARCHIVEENDING`
		fi
		if [ "$WORLDEDITCOMPATIBLE" ]
		# Don't store the complete path
		then
			as_user "cd $MCPATH && $COMPRESSCMD $path ${WORLDNAME[$INDEX]}"
		else
			as_user "$COMPRESSCMD $path $MCPATH/${WORLDNAME[$INDEX]}"
		fi
	done
}


check_links() {
	get_worlds
	for INDEX in ${!WORLDNAME[@]}
	do
		if [[ -L $MCPATH/${WORLDNAME[$INDEX]} || ! -a $MCPATH/${WORLDNAME[$INDEX]} ]]
		then
			link=`ls -l $MCPATH/${WORLDNAME[$INDEX]} | awk '{print $11}'`
			if ${WORLDRAM[$INDEX]}
			then
				if [ "$link" != "$RAMDISK/${WORLDNAME[$INDEX]}" ]
				then
					as_user "rm -f $MCPATH/${WORLDNAME[$INDEX]}"
					as_user "ln -s $RAMDISK/${WORLDNAME[$INDEX]} $MCPATH/${WORLDNAME[$INDEX]}"
					echo_out "Created link for ${WORLDNAME[$INDEX]}"
				fi
			else
				if [ "$link" != "${WORLDSTORAGE}/${WORLDNAME[$INDEX]}" ]
				then
					as_user "rm -f $MCPATH/${WORLDNAME[$INDEX]}"
					as_user "ln -s ${WORLDSTORAGE}/${WORLDNAME[$INDEX]} $MCPATH/${WORLDNAME[$INDEX]}"
					echo_out "Created link for ${WORLDNAME[$INDEX]}"
				fi
			fi
		else
			echo_err "Could not process the world named '${WORLDNAME[$INDEX]}'. Please move all worlds to ${WORLDSTORAGE}."

			exit 1
		fi
	done
}


to_ram() {
	get_worlds
	for INDEX in ${!WORLDNAME[@]}
	do
		if ${WORLDRAM[$INDEX]}
		then
			if [ -L $MCPATH/${WORLDNAME[$INDEX]} ]
			then
				as_user "mkdir -p $RAMDISK"
				as_user "rsync -rt --exclude 'ramdisk' ${WORLDSTORAGE}/${WORLDNAME[$INDEX]}/ $RAMDISK/${WORLDNAME[$INDEX]}"
				echo_out "${WORLDNAME[$INDEX]} copied to ram"
			fi
		fi
	done
}


to_disk() {
	get_worlds
	for INDEX in ${!WORLDNAME[@]}
	do
		if ${WORLDRAM[$INDEX]}
		then
			as_user "rsync -rt --exclude 'ramdisk' $MCPATH/${WORLDNAME[$INDEX]}/ ${WORLDSTORAGE}/${WORLDNAME[$INDEX]}"
			echo_out "${WORLDNAME[$INDEX]} copied to disk"
		fi
	done
}


check_update_vanilla() {
	MC_SERVER_URL=`wget -q -O - https://minecraft.net/download/server | grep --perl-regexp --only-matching --regexp='(?<=href=")http[^"]*minecraft_server[^"]*\.jar(?=")'`

	echo_out "Checking for update for minecraft_server.jar (Vanilla)"
	as_user "cd $MCPATH && wget -q -O $MCPATH/minecraft_server.jar.update $MC_SERVER_URL"

	if [ -r "$MCPATH/minecraft_server.jar.update" ]
	then
		if `diff $MCPATH/$MC_JAR $MCPATH/minecraft_server.jar.update >/dev/null`
		then
			echo_out "You are already running the latest version of minecraft_server.jar."
			return 1
		else
			echo_out "Update of $MC_JAR is needed."
			return 0
		fi
	else
		echo_err "Something went wrong. Couldn't download minecraft_server.jar"
	fi
}


get_cb_release_channel() {
	CB_URL="http://dl.bukkit.org/latest-"

	case $CB_RELEASE in
		unstable|UNSTABLE|Unstable|dev|development)
			echo_quiet $CB_URL"dev/craftbukkit.jar"
		;;


		beta|Beta|BETA)
			echo_quiet $CB_URL"beta/craftbukkit.jar"
		;;


		*)
			echo_quiet $CB_URL"rb/craftbukkit.jar"
		;;


	esac
}


check_update_craftbukkit() {
	echo_info "Checking for update for craftbukkit.jar"
	echo_info "You are on release channel \"$CB_RELEASE\""

	as_user "cd $MCPATH && wget -q -O $MCPATH/craftbukkit.jar.update $(get_cb_release_channel)"
	if [ -r "$MCPATH/craftbukkit.jar.update" ]
	then
		if `diff $MCPATH/$CB_JAR $MCPATH/craftbukkit.jar.update >/dev/null`
		then
			echo_info "You are already running the latest version of craftbukkit.jar."
			return 1
		else
			echo_out "Update of $CB_JAR is needed."
			return 0
		fi
	else
		echo_err "Something went wrong. Couldn't download craftbukkit.jar"
	fi
}


mc_update() {
	if is_running
	then
		echo_err "$SERVICE is running! Will not start update."
	else
		if check_update_vanilla
		then
			if [ -r "$MCPATH/minecraft_server.jar.update" ]
			then
				as_user "mv $MCPATH/minecraft_server.jar.update $MCPATH/$MC_JAR"
				echo_out "Thats it. Update of $MC_JAR done."
			else
				echo_err "Something went wrong. Couldn't replace your original $MC_JAR with minecraft_server.jar.update"
			fi
		else
			echo_out "Not updating $MB_JAR. It's not necessary"
			as_user "rm $MCPATH/minecraft_server.jar.update"
		fi

		if check_update_craftbukkit
		then
			if [ -r "$MCPATH/craftbukkit.jar.update" ]
			then
				as_user "mv $MCPATH/craftbukkit.jar.update $MCPATH/$CB_JAR"
				echo_out "Thats it. Update of $CB_JAR done."
			else
				echo_err "Something went wrong. Couldn't replace your original $CB_JAR with craftbukkit.jar.update"
			fi
		else
			echo_out "Not updating $CB_JAR. It's not necessary"
			as_user "rm $MCPATH/craftbukkit.jar.update"
		fi
	fi
}


change_ramdisk_state() {
	if [ ! -e $WORLDSTORAGE/$1 ]
	then
		echo_err "World \"$1\" not found."
		exit 1
	fi

	if [ -e $WORLDSTORAGE/$1/ramdisk ]
	then
		rm $WORLDSTORAGE/$1/ramdisk
		echo_out "Removed ramdisk flag from \"$1\""
	else
		touch $WORLDSTORAGE/$1/ramdisk
		echo_out "Added ramdisk flag to \"$1\""
	fi
	echo_out "Changes will only take effect after server is restarted."
}


overviewer_start() {
		if [ ! -e $OVPATH/overviewer.py ]
		then
				if [ ! "$OVPATH" == "apt" ]
				then
						echo_err "Minecraft-Overviewer is not installed in \"$OVPATH\""
						exit 1
				else
						echo_out "Using APT repository installed Minecraft-Overviewer"
				fi
		fi
		if [ ! -e $OUTPUTMAP ]
		then
				as_user "mkdir -p $OUTPUTMAP"
		fi
		if [ -e $OVCONFIGPATH/$OVCONFIGNAME ]
		then
				echo_out "Start generating map with Minecraft-Overviewer..."
				if [ "$OVPATH" == "apt" ]
				then
						as_user "overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME"
				else
						as_user "python $OVPATH/overviewer.py --config=$OVCONFIGPATH/$OVCONFIGNAME"
				fi
				echo_out "Map generated."
		else
				echo_err "No config file found. Start with default config..."
				if [ -z $1 ] || [ ! -e $OVBACKUP/$1 ]
				then
						echo_err "World \"$1\" not found."
				else
						echo_out "Start generating map with Minecraft-Overviewer..."
						if [ "$OVPATH" == "apt" ]
						then
								as_user "nice overviewer.py $OVBACKUP/$1 $OUTPUTMAP"
						else
								as_user "nice python $OVPATH/overviewer.py $OVBACKUP/$1 $OUTPUTMAP"
						fi
						echo_out "Map generated."
				fi
		fi
}


overviewer_copy_worlds() {
	#
	# Backup the worlds for overviewer
	#

	get_worlds
	for INDEX in ${!WORLDNAME[@]}
	do
		echo_out "Copying minecraft ${WORLDNAME[$INDEX]}."
		as_user "mkdir -p $OVBACKUP"
		as_user "rsync -rt --delete $WORLDSTORAGE/${WORLDNAME[$INDEX]} $OVBACKUP/${WORLDNAME[$INDEX]}"
	done
}



########
# Queries the Server for the list of users, then outputs to stdout
#
# Globals
#	SERVERLOG		The file that holds the Server's output
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout			Formated list of users currently connected to the server
########
function echo_connected_players() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	# query server & wait for response
	mc_command list || return 1;
	sleep 1s;


	local players;


	# get the list from log
	players="$(tac "$SERVERLOG" | grep --before-context 1 --max-count 1 'players online' | head -n 1)";
	echo_debug "players=$players";

	if [ -z "$players" ]; then
		echo_err "Can't find connected players in \$SERVER_LOG; quitting";
		return 1;
	fi;


	# remove the log-fluff
	players="${players:33}";


	# handle zero-players
	if [ -z "$players" ]; then
		players='No players connected';
	fi;
	echo_debug "players=$players";


	# change line to list
	players="${players//, /\\n\\t}";


	# print & return
	echo_info	"These players are connected:"
	echo_quiet	"\t$players";
	return 0;
}



########
# Wraps echo_connected_players() to return a count
#
# Globals
#	None
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout			Integer count of players online
########
function echo_playercount() {
	if ! is_running; then
		echo_info "No running server; skipping"
		return 0;
	fi;


	local cache=$VERBOSITY;	# cache the current VERBOSITY
	VERBOSITY=$VERBOSITY_QUIET;	# set to known level (quiet)
	local player_list="$(echo_connected_players)";
	VERBOSITY=$cache;	# reset VERBOSITY
	echo_debug "player_list=$player_list";


	# if no users; skip
	if [ 'No users connected' = "$player_list" ]; then
		echo_quiet 0;
		return 0;
	fi;


	# count the words (usernames); output
	echo_info	"There are this many players online:";
	echo_quiet	"$(echo "$player_list" | wc -w)";


	return 0;
}



########
# Checks server-log for recent player activity
#
# Globals
#	SERVERLOG	File containing player activity
#
# Arguments
#	None
#
# Returns
#	0|1
#	stdout		Formatted list of recent player activity
########
function echo_recent_players() {
	if ! is_running; then
		echo_out "Server is not running; skipping";
		return 0;
	fi


	# get the log & filter for player activity
	echo_debug "SERVERLOG=$SERVERLOG";
	if [ ! -f "$SERVERLOG" ]; then
		echo_err "Can't find \$SERVERLOG ($SERVERLOG); quitting";
		return 1;
	fi;
	local log="$(cat $SERVERLOG | grep 'joined the game\|left the game')";
	echo_debug "log=$log";


	# format for display
	log="${log// \[Server thread\/INFO\]/}";
	if [ -z "$log" ]; then
		log="No recent players";
	fi;
	echo_debug "log=$log";


	# output
	echo_info "Recently player activity:";
	echo_quiet "$log";


	return 0;
}



########
# Queries the Server Jar for the whitelist, then returns it
#
# Globals
#	SERVERLOG	File that holds the server's output
#
# Arguments
#	None
#
# Returns
#	0|1
########
echo_whitelist(){
	# query server and wait for reply
	mc_command "whitelist list" || return 1;
	sleep 1s;

	local whitelist;

	# extract data from log
	whitelist="$(tac "$SERVERLOG" | grep -m 1 -B 1 'whitelisted players:' | head -n 1)";
	whitelist="${whitelist:33}";			# remove the log-fluff
	whitelist="${whitelist// and /, }";		# remove ' and '
	whitelist="${whitelist//, /\\n\\t}";	# change line to list

	# Pre MC v1.8.8
	if [ -z "$whitelist" ]; then
		whitelist="$(tac "$SERVERLOG" | grep -m 1 'White-listed players:')";
		whitelist="${whitelist:49}";	# remove the log-fluff
		whitelist="${whitelist//, /\n}";	# change line to list
	fi;

	echo_out	"Your whitelist is:"
	echo_quiet	"\t$whitelist";

	return 0;
}


force_exit() {  # Kill the server running (messily) in an emergency
	echo_out ""
	echo_out "SIGINIT CALLED - FORCE EXITING!"
	pidfile=${MCPATH}/${SCREEN}.pid
	rm $pidfile
	echo_out "KILLING SERVER PROCESSES!!!"
		# Display which processes are being killed
		ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}
		ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}
		ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i echo "Killing PID: " {}

		# Kill the processes
		ps aux | grep -e 'java -Xmx' | grep -v grep | awk '{print $2}' | xargs -i kill {}
		ps aux | grep -e 'SCREEN -dmS minecraft java' | grep -v grep | awk '{print $2}' | xargs -i kill {}
		ps aux | grep -e '/etc/init.d/minecraft' | grep -v grep | awk '{print $2}' | xargs -i kill {}

	exit 1
}


get_script_location() {
	echo_quiet $(dirname "$(readlink -e "$0")")
}


check_permissions() {
	as_user "touch $pidfile"
	if ! as_user "test -w '$pidfile'" ; then
		echo_err "Check Permissions. Cannot write to $pidfile. Correct the permissions and then excute: $0 status"
	fi
}



########
# Decide with function(s) to call, based on commandline call
#
# Globals
#	INIT_COMMAND		(Main) command to run
#	INIT_SUBCOMMAND		Variant of <command> to run
#
# Arguments
#	@					All parameters, to pass to e.g. redirect functions
#
# Returns
#	0|1
########
function route_command() {
	echo_debug "@=$*";
	echo_debug "INIT_COMMAND=$INIT_COMMAND";
	echo_debug "INIT_SUBCOMMAND=$INIT_SUBCOMMAND";


	case "$INIT_COMMAND" in
		start)
			# Starts the server
			if is_running; then
				echo_out "Server already running."
			else
				check_links
				to_ram
				mc_start
			fi
			;;


		stop)
			# Stops the server
			if is_running; then
				mc_say "SERVER SHUTTING DOWN!"
				mc_stop
				to_disk
			else
				echo_out "No running server."
			fi
			;;


		restart)
			# Restarts the server
			if is_running; then
				mc_say "SERVER REBOOT IN 10 SECONDS!"
				mc_stop
				to_disk
			else
				echo_out "No running server, starting it..."
			fi
			check_links
			to_ram
			mc_start
			;;
			reload)
					# Reloads server configuration
					if is_running; then
							mc_say "Reloading server configuration.."
							mc_reload
					else
							echo_out "No running server."
					fi
					;;


		whitelist)
			if is_running; then
				echo_whitelist || return 1;
			else
				echo_out "Server not running."
			fi
			;;


		whitelist-reload)
			# Reloads the whitelist
			if is_running; then
				mc_command "whitelist reload"
			else
				echo_out "No running server."
			fi
			;;


		whitelist-add)
			# Adds a player to the whitelist
			if is_running; then
				mc_command "whitelist add $INIT_SUBCOMMAND"
			else
				echo_out "No running server."
			fi
			;;


		backup)
			# Backups world
			if is_running; then
				mc_say "Backing up world."
				mc_saveoff
				to_disk
				mc_world_backup
				mc_saveon
				mc_say "Backup complete."
			else
				mc_world_backup
			fi
			;;


		whole-backup)
			# Backup everything
			if is_running; then
				mc_say "COMPLETE SERVER BACKUP IN 10 SECONDS.";
				mc_say "WARNING: WILL RESTART SERVER SOFTWARE!"
				mc_stop
				to_disk
				mc_whole_backup
				check_links
				mc_start
			else
				mc_whole_backup
			fi
			;;


		check-update)
			check_update_vanilla
			check_update_craftbukkit
			as_user "rm $MCPATH/minecraft_server.jar.update"
			as_user "rm $MCPATH/craftbukkit.jar.update"
			;;


		update)
			#update minecraft_server.jar and craftbukkit.jar (thanks karrth)
			if is_running; then
				mc_say "SERVER UPDATE IN 10 SECONDS."
				mc_stop
				to_disk
				mc_whole_backup
				mc_update
				check_links
				mc_start
			else
				mc_whole_backup
				mc_update
			fi
			;;


		to-disk)
			# Writes from the ramdisk to disk, in case the server crashes.
			mc_saveoff
			to_disk
			mc_saveon
			;;


		save-off)
			# Flushes the state of the world to disk, and then disables
			# saving until save-on is called (useful if you have your own
			# backup scripts).
			if is_running; then
				mc_saveoff
			else
				echo_out "Server was not running, syncing from ram anyway..."
			fi
			to_disk
			;;


		save-on)
			# Re-enables saving if it was disabled by save-off.
			if is_running; then
				mc_saveon
			else
				echo_out "No running server."
			fi
			;;


		say)
			# Says something to the ingame chat
			if is_running; then
				shift 1
				mc_say "$INIT_SUBCOMMAND"
			else
				echo_out "No running server to say anything."
			fi
			;;


		command)
			if is_running; then
				shift 1
				mc_command "$INIT_SUBCOMMAND"
				echo_out "Sent command: \"$INIT_SUBCOMMAND\"";
			else
				echo_out "No running server to send a command to."
			fi
			;;


		connected)
			echo_connected_players || return 1;
			;;


		playercount)
			echo_playercount || return 1;
			;;


		log-roll)
			log_roll
			;;


		log)
			# Display server log using 'cat'.
			cat $SERVERLOG
			;;


		last)
			echo_recent_players || return 1;
			;;


		status)
			# Shows server status
			if is_running
			then
				echo_quiet "$SERVICE is running."
			else
				echo_quiet "$SERVICE is not running."
			fi
			;;


		watchdog)
			# Ensures server is still running
			if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
			then
				echo_out "$SERVICE is running."
			else
				mc_stop
				mc_start
			fi
			;;


		version)
			if is_running; then
				mc_command version
				tac $SERVERLOG | grep -m 1 "This server is running"
			else
				echo_out "The server needs to be running to check version."
			fi
			;;


		links)
			check_links
			;;


		ramdisk)
			change_ramdisk_state $INIT_SUBCOMMAND
			;;


		worlds)
			get_worlds
			for INDEX in ${!WORLDNAME[@]}
			do
				if ${WORLDRAM[$INDEX]}
				then
					echo_quiet "${WORLDNAME[$INDEX]} (ramdisk)"
				else
					echo_quiet ${WORLDNAME[$INDEX]}
				fi
			done
			;;


		overviewer)
			if is_running; then
				mc_say "Generating overviewer map."
				mc_saveoff
				to_disk
				overviewer_copy_worlds
				mc_saveon
				overviewer_start $INIT_SUBCOMMAND
			else
				overviewer_copy_worlds
				overviewer_start $INIT_SUBCOMMAND
			fi
			;;


		screen)
			if is_running; then
				as_user "script /dev/null -q -c \"screen -rx $SCREEN\""
			else
			echo_info "Server is not running. Do you want to start it?"
			echo_quiet "Please put \"Yes\", or \"No\": "
			read START_SERVER
			case "$START_SERVER" in
				[Yy]|[Yy][Ee][Ss])
					check_links
					to_ram
					mc_start
					as_user "script /dev/null -q -c \"screen -rx $SCREEN\""
					;;


				[Nn]|[Nn][Oo])
					clear
					echo_err "Aborting startup!"
					sleep 1
					clear
					exit 1
					;;


				*)
					clear
					echo_err "Invalid input"
					sleep 1
					clear
					exit 1
					;;


			esac
			fi
			;;


		kill)
			WIDTH=`stty size | cut -d ' ' -f 2`            # Get terminal's character width
			pstree | grep MDSImporte | cut -c 1-${WIDTH}   # Chop output after WIDTH chars

			echo_out "Killing the server is an EMERGENCY procedure, and should not be used to perform a normal shutdown! All changes younger than 15 minutes could be permanantly lost and WORLD CORRUPTION is possible! Are you ABSOLUTELY POSITIVE this is what you want to do?"
			echo_quiet "Please put \"Yes\", or \"No\": "
			read KILL_SERVER
			case "$KILL_SERVER" in  # Determine which option was specified
				[Yy]|[Yy][Ee][Ss])      # If yes, kill the server
					echo_err "KILLING SERVER PROCESSES!!!"
					force_exit
					exit 1
					;;


				[Nn]|[Nn][Oo])  # If no, abort and exit 1
					echo_err "Aborting!"
					exit 1
					;;


				*)      # If anything else, exit 1
					echo_err "Error: Invalid Input!"
					exit 1
					;;


			esac
			;;


		help|--help|-h)
			echo_usage;
			;;


		mci-version|mci_version|script-version|script_version)
			echo_mci_version;
			;;


		*)
			echo_err "No such command as '$(basename "$0") $INIT_COMMAND'; quitting";
			echo;
			echo_usage;
			exit 1
			;;
	esac
	
	
	return 0;
}



###############################################################################
## Run, tidy, quit
###############################################################################


# Loads config file
if [ -L $0 ]
then
	source `readlink -e $0 | sed "s:[^/]*$:config:"`
else
	source `echo $0 | sed "s:[^/]*$:config:"`
fi

if [ "$SERVICE" == "" ]
then
	echo_err "Couldn't load config file, please edit config.example and rename it to config"
	logger -t minecraft-init "Couldn't load config file, please edit config.example and rename it to config"
	exit
fi


trap force_exit SIGINT


handle_commandline_options "$@" || exit 1;
route_command "$@" || exit 1;	# need to inject $@ so route_command() can pass it on


exit 0
